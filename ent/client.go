// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"viktor/ent/migrate"

	"viktor/ent/abteilung"
	"viktor/ent/angebot"
	"viktor/ent/ansprechpartner"
	"viktor/ent/aussteller"
	"viktor/ent/einkauf"
	"viktor/ent/job"
	"viktor/ent/lieferant"
	"viktor/ent/mitarbeiter"
	"viktor/ent/partner"
	"viktor/ent/pdf"
	"viktor/ent/statu"
	"viktor/ent/warenlieferung"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Abteilung is the client for interacting with the Abteilung builders.
	Abteilung *AbteilungClient
	// Angebot is the client for interacting with the Angebot builders.
	Angebot *AngebotClient
	// Ansprechpartner is the client for interacting with the Ansprechpartner builders.
	Ansprechpartner *AnsprechpartnerClient
	// Aussteller is the client for interacting with the Aussteller builders.
	Aussteller *AusstellerClient
	// Einkauf is the client for interacting with the Einkauf builders.
	Einkauf *EinkaufClient
	// Job is the client for interacting with the Job builders.
	Job *JobClient
	// Lieferant is the client for interacting with the Lieferant builders.
	Lieferant *LieferantClient
	// Mitarbeiter is the client for interacting with the Mitarbeiter builders.
	Mitarbeiter *MitarbeiterClient
	// Partner is the client for interacting with the Partner builders.
	Partner *PartnerClient
	// Pdf is the client for interacting with the Pdf builders.
	Pdf *PdfClient
	// Statu is the client for interacting with the Statu builders.
	Statu *StatuClient
	// Warenlieferung is the client for interacting with the Warenlieferung builders.
	Warenlieferung *WarenlieferungClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Abteilung = NewAbteilungClient(c.config)
	c.Angebot = NewAngebotClient(c.config)
	c.Ansprechpartner = NewAnsprechpartnerClient(c.config)
	c.Aussteller = NewAusstellerClient(c.config)
	c.Einkauf = NewEinkaufClient(c.config)
	c.Job = NewJobClient(c.config)
	c.Lieferant = NewLieferantClient(c.config)
	c.Mitarbeiter = NewMitarbeiterClient(c.config)
	c.Partner = NewPartnerClient(c.config)
	c.Pdf = NewPdfClient(c.config)
	c.Statu = NewStatuClient(c.config)
	c.Warenlieferung = NewWarenlieferungClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Abteilung:       NewAbteilungClient(cfg),
		Angebot:         NewAngebotClient(cfg),
		Ansprechpartner: NewAnsprechpartnerClient(cfg),
		Aussteller:      NewAusstellerClient(cfg),
		Einkauf:         NewEinkaufClient(cfg),
		Job:             NewJobClient(cfg),
		Lieferant:       NewLieferantClient(cfg),
		Mitarbeiter:     NewMitarbeiterClient(cfg),
		Partner:         NewPartnerClient(cfg),
		Pdf:             NewPdfClient(cfg),
		Statu:           NewStatuClient(cfg),
		Warenlieferung:  NewWarenlieferungClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Abteilung:       NewAbteilungClient(cfg),
		Angebot:         NewAngebotClient(cfg),
		Ansprechpartner: NewAnsprechpartnerClient(cfg),
		Aussteller:      NewAusstellerClient(cfg),
		Einkauf:         NewEinkaufClient(cfg),
		Job:             NewJobClient(cfg),
		Lieferant:       NewLieferantClient(cfg),
		Mitarbeiter:     NewMitarbeiterClient(cfg),
		Partner:         NewPartnerClient(cfg),
		Pdf:             NewPdfClient(cfg),
		Statu:           NewStatuClient(cfg),
		Warenlieferung:  NewWarenlieferungClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Abteilung.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Abteilung, c.Angebot, c.Ansprechpartner, c.Aussteller, c.Einkauf, c.Job,
		c.Lieferant, c.Mitarbeiter, c.Partner, c.Pdf, c.Statu, c.Warenlieferung,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Abteilung, c.Angebot, c.Ansprechpartner, c.Aussteller, c.Einkauf, c.Job,
		c.Lieferant, c.Mitarbeiter, c.Partner, c.Pdf, c.Statu, c.Warenlieferung,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AbteilungMutation:
		return c.Abteilung.mutate(ctx, m)
	case *AngebotMutation:
		return c.Angebot.mutate(ctx, m)
	case *AnsprechpartnerMutation:
		return c.Ansprechpartner.mutate(ctx, m)
	case *AusstellerMutation:
		return c.Aussteller.mutate(ctx, m)
	case *EinkaufMutation:
		return c.Einkauf.mutate(ctx, m)
	case *JobMutation:
		return c.Job.mutate(ctx, m)
	case *LieferantMutation:
		return c.Lieferant.mutate(ctx, m)
	case *MitarbeiterMutation:
		return c.Mitarbeiter.mutate(ctx, m)
	case *PartnerMutation:
		return c.Partner.mutate(ctx, m)
	case *PdfMutation:
		return c.Pdf.mutate(ctx, m)
	case *StatuMutation:
		return c.Statu.mutate(ctx, m)
	case *WarenlieferungMutation:
		return c.Warenlieferung.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AbteilungClient is a client for the Abteilung schema.
type AbteilungClient struct {
	config
}

// NewAbteilungClient returns a client for the Abteilung from the given config.
func NewAbteilungClient(c config) *AbteilungClient {
	return &AbteilungClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `abteilung.Hooks(f(g(h())))`.
func (c *AbteilungClient) Use(hooks ...Hook) {
	c.hooks.Abteilung = append(c.hooks.Abteilung, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `abteilung.Intercept(f(g(h())))`.
func (c *AbteilungClient) Intercept(interceptors ...Interceptor) {
	c.inters.Abteilung = append(c.inters.Abteilung, interceptors...)
}

// Create returns a builder for creating a Abteilung entity.
func (c *AbteilungClient) Create() *AbteilungCreate {
	mutation := newAbteilungMutation(c.config, OpCreate)
	return &AbteilungCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Abteilung entities.
func (c *AbteilungClient) CreateBulk(builders ...*AbteilungCreate) *AbteilungCreateBulk {
	return &AbteilungCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AbteilungClient) MapCreateBulk(slice any, setFunc func(*AbteilungCreate, int)) *AbteilungCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AbteilungCreateBulk{err: fmt.Errorf("calling to AbteilungClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AbteilungCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AbteilungCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Abteilung.
func (c *AbteilungClient) Update() *AbteilungUpdate {
	mutation := newAbteilungMutation(c.config, OpUpdate)
	return &AbteilungUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AbteilungClient) UpdateOne(a *Abteilung) *AbteilungUpdateOne {
	mutation := newAbteilungMutation(c.config, OpUpdateOne, withAbteilung(a))
	return &AbteilungUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AbteilungClient) UpdateOneID(id string) *AbteilungUpdateOne {
	mutation := newAbteilungMutation(c.config, OpUpdateOne, withAbteilungID(id))
	return &AbteilungUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Abteilung.
func (c *AbteilungClient) Delete() *AbteilungDelete {
	mutation := newAbteilungMutation(c.config, OpDelete)
	return &AbteilungDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AbteilungClient) DeleteOne(a *Abteilung) *AbteilungDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AbteilungClient) DeleteOneID(id string) *AbteilungDeleteOne {
	builder := c.Delete().Where(abteilung.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AbteilungDeleteOne{builder}
}

// Query returns a query builder for Abteilung.
func (c *AbteilungClient) Query() *AbteilungQuery {
	return &AbteilungQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAbteilung},
		inters: c.Interceptors(),
	}
}

// Get returns a Abteilung entity by its id.
func (c *AbteilungClient) Get(ctx context.Context, id string) (*Abteilung, error) {
	return c.Query().Where(abteilung.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AbteilungClient) GetX(ctx context.Context, id string) *Abteilung {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMitarbeiters queries the mitarbeiters edge of a Abteilung.
func (c *AbteilungClient) QueryMitarbeiters(a *Abteilung) *MitarbeiterQuery {
	query := (&MitarbeiterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(abteilung.Table, abteilung.FieldID, id),
			sqlgraph.To(mitarbeiter.Table, mitarbeiter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, abteilung.MitarbeitersTable, abteilung.MitarbeitersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AbteilungClient) Hooks() []Hook {
	return c.hooks.Abteilung
}

// Interceptors returns the client interceptors.
func (c *AbteilungClient) Interceptors() []Interceptor {
	return c.inters.Abteilung
}

func (c *AbteilungClient) mutate(ctx context.Context, m *AbteilungMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AbteilungCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AbteilungUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AbteilungUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AbteilungDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Abteilung mutation op: %q", m.Op())
	}
}

// AngebotClient is a client for the Angebot schema.
type AngebotClient struct {
	config
}

// NewAngebotClient returns a client for the Angebot from the given config.
func NewAngebotClient(c config) *AngebotClient {
	return &AngebotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `angebot.Hooks(f(g(h())))`.
func (c *AngebotClient) Use(hooks ...Hook) {
	c.hooks.Angebot = append(c.hooks.Angebot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `angebot.Intercept(f(g(h())))`.
func (c *AngebotClient) Intercept(interceptors ...Interceptor) {
	c.inters.Angebot = append(c.inters.Angebot, interceptors...)
}

// Create returns a builder for creating a Angebot entity.
func (c *AngebotClient) Create() *AngebotCreate {
	mutation := newAngebotMutation(c.config, OpCreate)
	return &AngebotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Angebot entities.
func (c *AngebotClient) CreateBulk(builders ...*AngebotCreate) *AngebotCreateBulk {
	return &AngebotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AngebotClient) MapCreateBulk(slice any, setFunc func(*AngebotCreate, int)) *AngebotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AngebotCreateBulk{err: fmt.Errorf("calling to AngebotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AngebotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AngebotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Angebot.
func (c *AngebotClient) Update() *AngebotUpdate {
	mutation := newAngebotMutation(c.config, OpUpdate)
	return &AngebotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AngebotClient) UpdateOne(a *Angebot) *AngebotUpdateOne {
	mutation := newAngebotMutation(c.config, OpUpdateOne, withAngebot(a))
	return &AngebotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AngebotClient) UpdateOneID(id string) *AngebotUpdateOne {
	mutation := newAngebotMutation(c.config, OpUpdateOne, withAngebotID(id))
	return &AngebotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Angebot.
func (c *AngebotClient) Delete() *AngebotDelete {
	mutation := newAngebotMutation(c.config, OpDelete)
	return &AngebotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AngebotClient) DeleteOne(a *Angebot) *AngebotDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AngebotClient) DeleteOneID(id string) *AngebotDeleteOne {
	builder := c.Delete().Where(angebot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AngebotDeleteOne{builder}
}

// Query returns a query builder for Angebot.
func (c *AngebotClient) Query() *AngebotQuery {
	return &AngebotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAngebot},
		inters: c.Interceptors(),
	}
}

// Get returns a Angebot entity by its id.
func (c *AngebotClient) Get(ctx context.Context, id string) (*Angebot, error) {
	return c.Query().Where(angebot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AngebotClient) GetX(ctx context.Context, id string) *Angebot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AngebotClient) Hooks() []Hook {
	return c.hooks.Angebot
}

// Interceptors returns the client interceptors.
func (c *AngebotClient) Interceptors() []Interceptor {
	return c.inters.Angebot
}

func (c *AngebotClient) mutate(ctx context.Context, m *AngebotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AngebotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AngebotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AngebotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AngebotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Angebot mutation op: %q", m.Op())
	}
}

// AnsprechpartnerClient is a client for the Ansprechpartner schema.
type AnsprechpartnerClient struct {
	config
}

// NewAnsprechpartnerClient returns a client for the Ansprechpartner from the given config.
func NewAnsprechpartnerClient(c config) *AnsprechpartnerClient {
	return &AnsprechpartnerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ansprechpartner.Hooks(f(g(h())))`.
func (c *AnsprechpartnerClient) Use(hooks ...Hook) {
	c.hooks.Ansprechpartner = append(c.hooks.Ansprechpartner, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ansprechpartner.Intercept(f(g(h())))`.
func (c *AnsprechpartnerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ansprechpartner = append(c.inters.Ansprechpartner, interceptors...)
}

// Create returns a builder for creating a Ansprechpartner entity.
func (c *AnsprechpartnerClient) Create() *AnsprechpartnerCreate {
	mutation := newAnsprechpartnerMutation(c.config, OpCreate)
	return &AnsprechpartnerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ansprechpartner entities.
func (c *AnsprechpartnerClient) CreateBulk(builders ...*AnsprechpartnerCreate) *AnsprechpartnerCreateBulk {
	return &AnsprechpartnerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnsprechpartnerClient) MapCreateBulk(slice any, setFunc func(*AnsprechpartnerCreate, int)) *AnsprechpartnerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnsprechpartnerCreateBulk{err: fmt.Errorf("calling to AnsprechpartnerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnsprechpartnerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnsprechpartnerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ansprechpartner.
func (c *AnsprechpartnerClient) Update() *AnsprechpartnerUpdate {
	mutation := newAnsprechpartnerMutation(c.config, OpUpdate)
	return &AnsprechpartnerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnsprechpartnerClient) UpdateOne(a *Ansprechpartner) *AnsprechpartnerUpdateOne {
	mutation := newAnsprechpartnerMutation(c.config, OpUpdateOne, withAnsprechpartner(a))
	return &AnsprechpartnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnsprechpartnerClient) UpdateOneID(id string) *AnsprechpartnerUpdateOne {
	mutation := newAnsprechpartnerMutation(c.config, OpUpdateOne, withAnsprechpartnerID(id))
	return &AnsprechpartnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ansprechpartner.
func (c *AnsprechpartnerClient) Delete() *AnsprechpartnerDelete {
	mutation := newAnsprechpartnerMutation(c.config, OpDelete)
	return &AnsprechpartnerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnsprechpartnerClient) DeleteOne(a *Ansprechpartner) *AnsprechpartnerDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnsprechpartnerClient) DeleteOneID(id string) *AnsprechpartnerDeleteOne {
	builder := c.Delete().Where(ansprechpartner.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnsprechpartnerDeleteOne{builder}
}

// Query returns a query builder for Ansprechpartner.
func (c *AnsprechpartnerClient) Query() *AnsprechpartnerQuery {
	return &AnsprechpartnerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnsprechpartner},
		inters: c.Interceptors(),
	}
}

// Get returns a Ansprechpartner entity by its id.
func (c *AnsprechpartnerClient) Get(ctx context.Context, id string) (*Ansprechpartner, error) {
	return c.Query().Where(ansprechpartner.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnsprechpartnerClient) GetX(ctx context.Context, id string) *Ansprechpartner {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLieferant queries the lieferant edge of a Ansprechpartner.
func (c *AnsprechpartnerClient) QueryLieferant(a *Ansprechpartner) *LieferantQuery {
	query := (&LieferantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ansprechpartner.Table, ansprechpartner.FieldID, id),
			sqlgraph.To(lieferant.Table, lieferant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ansprechpartner.LieferantTable, ansprechpartner.LieferantColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnsprechpartnerClient) Hooks() []Hook {
	return c.hooks.Ansprechpartner
}

// Interceptors returns the client interceptors.
func (c *AnsprechpartnerClient) Interceptors() []Interceptor {
	return c.inters.Ansprechpartner
}

func (c *AnsprechpartnerClient) mutate(ctx context.Context, m *AnsprechpartnerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnsprechpartnerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnsprechpartnerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnsprechpartnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnsprechpartnerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ansprechpartner mutation op: %q", m.Op())
	}
}

// AusstellerClient is a client for the Aussteller schema.
type AusstellerClient struct {
	config
}

// NewAusstellerClient returns a client for the Aussteller from the given config.
func NewAusstellerClient(c config) *AusstellerClient {
	return &AusstellerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `aussteller.Hooks(f(g(h())))`.
func (c *AusstellerClient) Use(hooks ...Hook) {
	c.hooks.Aussteller = append(c.hooks.Aussteller, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `aussteller.Intercept(f(g(h())))`.
func (c *AusstellerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Aussteller = append(c.inters.Aussteller, interceptors...)
}

// Create returns a builder for creating a Aussteller entity.
func (c *AusstellerClient) Create() *AusstellerCreate {
	mutation := newAusstellerMutation(c.config, OpCreate)
	return &AusstellerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Aussteller entities.
func (c *AusstellerClient) CreateBulk(builders ...*AusstellerCreate) *AusstellerCreateBulk {
	return &AusstellerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AusstellerClient) MapCreateBulk(slice any, setFunc func(*AusstellerCreate, int)) *AusstellerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AusstellerCreateBulk{err: fmt.Errorf("calling to AusstellerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AusstellerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AusstellerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Aussteller.
func (c *AusstellerClient) Update() *AusstellerUpdate {
	mutation := newAusstellerMutation(c.config, OpUpdate)
	return &AusstellerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AusstellerClient) UpdateOne(a *Aussteller) *AusstellerUpdateOne {
	mutation := newAusstellerMutation(c.config, OpUpdateOne, withAussteller(a))
	return &AusstellerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AusstellerClient) UpdateOneID(id int32) *AusstellerUpdateOne {
	mutation := newAusstellerMutation(c.config, OpUpdateOne, withAusstellerID(id))
	return &AusstellerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Aussteller.
func (c *AusstellerClient) Delete() *AusstellerDelete {
	mutation := newAusstellerMutation(c.config, OpDelete)
	return &AusstellerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AusstellerClient) DeleteOne(a *Aussteller) *AusstellerDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AusstellerClient) DeleteOneID(id int32) *AusstellerDeleteOne {
	builder := c.Delete().Where(aussteller.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AusstellerDeleteOne{builder}
}

// Query returns a query builder for Aussteller.
func (c *AusstellerClient) Query() *AusstellerQuery {
	return &AusstellerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAussteller},
		inters: c.Interceptors(),
	}
}

// Get returns a Aussteller entity by its id.
func (c *AusstellerClient) Get(ctx context.Context, id int32) (*Aussteller, error) {
	return c.Query().Where(aussteller.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AusstellerClient) GetX(ctx context.Context, id int32) *Aussteller {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AusstellerClient) Hooks() []Hook {
	return c.hooks.Aussteller
}

// Interceptors returns the client interceptors.
func (c *AusstellerClient) Interceptors() []Interceptor {
	return c.inters.Aussteller
}

func (c *AusstellerClient) mutate(ctx context.Context, m *AusstellerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AusstellerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AusstellerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AusstellerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AusstellerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Aussteller mutation op: %q", m.Op())
	}
}

// EinkaufClient is a client for the Einkauf schema.
type EinkaufClient struct {
	config
}

// NewEinkaufClient returns a client for the Einkauf from the given config.
func NewEinkaufClient(c config) *EinkaufClient {
	return &EinkaufClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `einkauf.Hooks(f(g(h())))`.
func (c *EinkaufClient) Use(hooks ...Hook) {
	c.hooks.Einkauf = append(c.hooks.Einkauf, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `einkauf.Intercept(f(g(h())))`.
func (c *EinkaufClient) Intercept(interceptors ...Interceptor) {
	c.inters.Einkauf = append(c.inters.Einkauf, interceptors...)
}

// Create returns a builder for creating a Einkauf entity.
func (c *EinkaufClient) Create() *EinkaufCreate {
	mutation := newEinkaufMutation(c.config, OpCreate)
	return &EinkaufCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Einkauf entities.
func (c *EinkaufClient) CreateBulk(builders ...*EinkaufCreate) *EinkaufCreateBulk {
	return &EinkaufCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EinkaufClient) MapCreateBulk(slice any, setFunc func(*EinkaufCreate, int)) *EinkaufCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EinkaufCreateBulk{err: fmt.Errorf("calling to EinkaufClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EinkaufCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EinkaufCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Einkauf.
func (c *EinkaufClient) Update() *EinkaufUpdate {
	mutation := newEinkaufMutation(c.config, OpUpdate)
	return &EinkaufUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EinkaufClient) UpdateOne(e *Einkauf) *EinkaufUpdateOne {
	mutation := newEinkaufMutation(c.config, OpUpdateOne, withEinkauf(e))
	return &EinkaufUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EinkaufClient) UpdateOneID(id string) *EinkaufUpdateOne {
	mutation := newEinkaufMutation(c.config, OpUpdateOne, withEinkaufID(id))
	return &EinkaufUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Einkauf.
func (c *EinkaufClient) Delete() *EinkaufDelete {
	mutation := newEinkaufMutation(c.config, OpDelete)
	return &EinkaufDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EinkaufClient) DeleteOne(e *Einkauf) *EinkaufDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EinkaufClient) DeleteOneID(id string) *EinkaufDeleteOne {
	builder := c.Delete().Where(einkauf.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EinkaufDeleteOne{builder}
}

// Query returns a query builder for Einkauf.
func (c *EinkaufClient) Query() *EinkaufQuery {
	return &EinkaufQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEinkauf},
		inters: c.Interceptors(),
	}
}

// Get returns a Einkauf entity by its id.
func (c *EinkaufClient) Get(ctx context.Context, id string) (*Einkauf, error) {
	return c.Query().Where(einkauf.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EinkaufClient) GetX(ctx context.Context, id string) *Einkauf {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMitarbeiter queries the mitarbeiter edge of a Einkauf.
func (c *EinkaufClient) QueryMitarbeiter(e *Einkauf) *MitarbeiterQuery {
	query := (&MitarbeiterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(einkauf.Table, einkauf.FieldID, id),
			sqlgraph.To(mitarbeiter.Table, mitarbeiter.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, einkauf.MitarbeiterTable, einkauf.MitarbeiterColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EinkaufClient) Hooks() []Hook {
	return c.hooks.Einkauf
}

// Interceptors returns the client interceptors.
func (c *EinkaufClient) Interceptors() []Interceptor {
	return c.inters.Einkauf
}

func (c *EinkaufClient) mutate(ctx context.Context, m *EinkaufMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EinkaufCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EinkaufUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EinkaufUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EinkaufDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Einkauf mutation op: %q", m.Op())
	}
}

// JobClient is a client for the Job schema.
type JobClient struct {
	config
}

// NewJobClient returns a client for the Job from the given config.
func NewJobClient(c config) *JobClient {
	return &JobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `job.Hooks(f(g(h())))`.
func (c *JobClient) Use(hooks ...Hook) {
	c.hooks.Job = append(c.hooks.Job, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `job.Intercept(f(g(h())))`.
func (c *JobClient) Intercept(interceptors ...Interceptor) {
	c.inters.Job = append(c.inters.Job, interceptors...)
}

// Create returns a builder for creating a Job entity.
func (c *JobClient) Create() *JobCreate {
	mutation := newJobMutation(c.config, OpCreate)
	return &JobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Job entities.
func (c *JobClient) CreateBulk(builders ...*JobCreate) *JobCreateBulk {
	return &JobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobClient) MapCreateBulk(slice any, setFunc func(*JobCreate, int)) *JobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobCreateBulk{err: fmt.Errorf("calling to JobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Job.
func (c *JobClient) Update() *JobUpdate {
	mutation := newJobMutation(c.config, OpUpdate)
	return &JobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobClient) UpdateOne(j *Job) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJob(j))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobClient) UpdateOneID(id string) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJobID(id))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Job.
func (c *JobClient) Delete() *JobDelete {
	mutation := newJobMutation(c.config, OpDelete)
	return &JobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobClient) DeleteOne(j *Job) *JobDeleteOne {
	return c.DeleteOneID(j.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobClient) DeleteOneID(id string) *JobDeleteOne {
	builder := c.Delete().Where(job.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobDeleteOne{builder}
}

// Query returns a query builder for Job.
func (c *JobClient) Query() *JobQuery {
	return &JobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJob},
		inters: c.Interceptors(),
	}
}

// Get returns a Job entity by its id.
func (c *JobClient) Get(ctx context.Context, id string) (*Job, error) {
	return c.Query().Where(job.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobClient) GetX(ctx context.Context, id string) *Job {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *JobClient) Hooks() []Hook {
	return c.hooks.Job
}

// Interceptors returns the client interceptors.
func (c *JobClient) Interceptors() []Interceptor {
	return c.inters.Job
}

func (c *JobClient) mutate(ctx context.Context, m *JobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Job mutation op: %q", m.Op())
	}
}

// LieferantClient is a client for the Lieferant schema.
type LieferantClient struct {
	config
}

// NewLieferantClient returns a client for the Lieferant from the given config.
func NewLieferantClient(c config) *LieferantClient {
	return &LieferantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lieferant.Hooks(f(g(h())))`.
func (c *LieferantClient) Use(hooks ...Hook) {
	c.hooks.Lieferant = append(c.hooks.Lieferant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lieferant.Intercept(f(g(h())))`.
func (c *LieferantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lieferant = append(c.inters.Lieferant, interceptors...)
}

// Create returns a builder for creating a Lieferant entity.
func (c *LieferantClient) Create() *LieferantCreate {
	mutation := newLieferantMutation(c.config, OpCreate)
	return &LieferantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lieferant entities.
func (c *LieferantClient) CreateBulk(builders ...*LieferantCreate) *LieferantCreateBulk {
	return &LieferantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LieferantClient) MapCreateBulk(slice any, setFunc func(*LieferantCreate, int)) *LieferantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LieferantCreateBulk{err: fmt.Errorf("calling to LieferantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LieferantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LieferantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lieferant.
func (c *LieferantClient) Update() *LieferantUpdate {
	mutation := newLieferantMutation(c.config, OpUpdate)
	return &LieferantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LieferantClient) UpdateOne(l *Lieferant) *LieferantUpdateOne {
	mutation := newLieferantMutation(c.config, OpUpdateOne, withLieferant(l))
	return &LieferantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LieferantClient) UpdateOneID(id string) *LieferantUpdateOne {
	mutation := newLieferantMutation(c.config, OpUpdateOne, withLieferantID(id))
	return &LieferantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lieferant.
func (c *LieferantClient) Delete() *LieferantDelete {
	mutation := newLieferantMutation(c.config, OpDelete)
	return &LieferantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LieferantClient) DeleteOne(l *Lieferant) *LieferantDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LieferantClient) DeleteOneID(id string) *LieferantDeleteOne {
	builder := c.Delete().Where(lieferant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LieferantDeleteOne{builder}
}

// Query returns a query builder for Lieferant.
func (c *LieferantClient) Query() *LieferantQuery {
	return &LieferantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLieferant},
		inters: c.Interceptors(),
	}
}

// Get returns a Lieferant entity by its id.
func (c *LieferantClient) Get(ctx context.Context, id string) (*Lieferant, error) {
	return c.Query().Where(lieferant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LieferantClient) GetX(ctx context.Context, id string) *Lieferant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnsprechpartners queries the ansprechpartners edge of a Lieferant.
func (c *LieferantClient) QueryAnsprechpartners(l *Lieferant) *AnsprechpartnerQuery {
	query := (&AnsprechpartnerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lieferant.Table, lieferant.FieldID, id),
			sqlgraph.To(ansprechpartner.Table, ansprechpartner.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lieferant.AnsprechpartnersTable, lieferant.AnsprechpartnersColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LieferantClient) Hooks() []Hook {
	return c.hooks.Lieferant
}

// Interceptors returns the client interceptors.
func (c *LieferantClient) Interceptors() []Interceptor {
	return c.inters.Lieferant
}

func (c *LieferantClient) mutate(ctx context.Context, m *LieferantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LieferantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LieferantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LieferantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LieferantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Lieferant mutation op: %q", m.Op())
	}
}

// MitarbeiterClient is a client for the Mitarbeiter schema.
type MitarbeiterClient struct {
	config
}

// NewMitarbeiterClient returns a client for the Mitarbeiter from the given config.
func NewMitarbeiterClient(c config) *MitarbeiterClient {
	return &MitarbeiterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mitarbeiter.Hooks(f(g(h())))`.
func (c *MitarbeiterClient) Use(hooks ...Hook) {
	c.hooks.Mitarbeiter = append(c.hooks.Mitarbeiter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mitarbeiter.Intercept(f(g(h())))`.
func (c *MitarbeiterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Mitarbeiter = append(c.inters.Mitarbeiter, interceptors...)
}

// Create returns a builder for creating a Mitarbeiter entity.
func (c *MitarbeiterClient) Create() *MitarbeiterCreate {
	mutation := newMitarbeiterMutation(c.config, OpCreate)
	return &MitarbeiterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Mitarbeiter entities.
func (c *MitarbeiterClient) CreateBulk(builders ...*MitarbeiterCreate) *MitarbeiterCreateBulk {
	return &MitarbeiterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MitarbeiterClient) MapCreateBulk(slice any, setFunc func(*MitarbeiterCreate, int)) *MitarbeiterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MitarbeiterCreateBulk{err: fmt.Errorf("calling to MitarbeiterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MitarbeiterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MitarbeiterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Mitarbeiter.
func (c *MitarbeiterClient) Update() *MitarbeiterUpdate {
	mutation := newMitarbeiterMutation(c.config, OpUpdate)
	return &MitarbeiterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MitarbeiterClient) UpdateOne(m *Mitarbeiter) *MitarbeiterUpdateOne {
	mutation := newMitarbeiterMutation(c.config, OpUpdateOne, withMitarbeiter(m))
	return &MitarbeiterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MitarbeiterClient) UpdateOneID(id string) *MitarbeiterUpdateOne {
	mutation := newMitarbeiterMutation(c.config, OpUpdateOne, withMitarbeiterID(id))
	return &MitarbeiterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Mitarbeiter.
func (c *MitarbeiterClient) Delete() *MitarbeiterDelete {
	mutation := newMitarbeiterMutation(c.config, OpDelete)
	return &MitarbeiterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MitarbeiterClient) DeleteOne(m *Mitarbeiter) *MitarbeiterDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MitarbeiterClient) DeleteOneID(id string) *MitarbeiterDeleteOne {
	builder := c.Delete().Where(mitarbeiter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MitarbeiterDeleteOne{builder}
}

// Query returns a query builder for Mitarbeiter.
func (c *MitarbeiterClient) Query() *MitarbeiterQuery {
	return &MitarbeiterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMitarbeiter},
		inters: c.Interceptors(),
	}
}

// Get returns a Mitarbeiter entity by its id.
func (c *MitarbeiterClient) Get(ctx context.Context, id string) (*Mitarbeiter, error) {
	return c.Query().Where(mitarbeiter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MitarbeiterClient) GetX(ctx context.Context, id string) *Mitarbeiter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAbteilung queries the abteilung edge of a Mitarbeiter.
func (c *MitarbeiterClient) QueryAbteilung(m *Mitarbeiter) *AbteilungQuery {
	query := (&AbteilungClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mitarbeiter.Table, mitarbeiter.FieldID, id),
			sqlgraph.To(abteilung.Table, abteilung.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mitarbeiter.AbteilungTable, mitarbeiter.AbteilungColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEinkauf queries the einkauf edge of a Mitarbeiter.
func (c *MitarbeiterClient) QueryEinkauf(m *Mitarbeiter) *EinkaufQuery {
	query := (&EinkaufClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mitarbeiter.Table, mitarbeiter.FieldID, id),
			sqlgraph.To(einkauf.Table, einkauf.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mitarbeiter.EinkaufTable, mitarbeiter.EinkaufColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MitarbeiterClient) Hooks() []Hook {
	return c.hooks.Mitarbeiter
}

// Interceptors returns the client interceptors.
func (c *MitarbeiterClient) Interceptors() []Interceptor {
	return c.inters.Mitarbeiter
}

func (c *MitarbeiterClient) mutate(ctx context.Context, m *MitarbeiterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MitarbeiterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MitarbeiterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MitarbeiterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MitarbeiterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Mitarbeiter mutation op: %q", m.Op())
	}
}

// PartnerClient is a client for the Partner schema.
type PartnerClient struct {
	config
}

// NewPartnerClient returns a client for the Partner from the given config.
func NewPartnerClient(c config) *PartnerClient {
	return &PartnerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `partner.Hooks(f(g(h())))`.
func (c *PartnerClient) Use(hooks ...Hook) {
	c.hooks.Partner = append(c.hooks.Partner, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `partner.Intercept(f(g(h())))`.
func (c *PartnerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Partner = append(c.inters.Partner, interceptors...)
}

// Create returns a builder for creating a Partner entity.
func (c *PartnerClient) Create() *PartnerCreate {
	mutation := newPartnerMutation(c.config, OpCreate)
	return &PartnerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Partner entities.
func (c *PartnerClient) CreateBulk(builders ...*PartnerCreate) *PartnerCreateBulk {
	return &PartnerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PartnerClient) MapCreateBulk(slice any, setFunc func(*PartnerCreate, int)) *PartnerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PartnerCreateBulk{err: fmt.Errorf("calling to PartnerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PartnerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PartnerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Partner.
func (c *PartnerClient) Update() *PartnerUpdate {
	mutation := newPartnerMutation(c.config, OpUpdate)
	return &PartnerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartnerClient) UpdateOne(pa *Partner) *PartnerUpdateOne {
	mutation := newPartnerMutation(c.config, OpUpdateOne, withPartner(pa))
	return &PartnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartnerClient) UpdateOneID(id string) *PartnerUpdateOne {
	mutation := newPartnerMutation(c.config, OpUpdateOne, withPartnerID(id))
	return &PartnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Partner.
func (c *PartnerClient) Delete() *PartnerDelete {
	mutation := newPartnerMutation(c.config, OpDelete)
	return &PartnerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartnerClient) DeleteOne(pa *Partner) *PartnerDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartnerClient) DeleteOneID(id string) *PartnerDeleteOne {
	builder := c.Delete().Where(partner.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartnerDeleteOne{builder}
}

// Query returns a query builder for Partner.
func (c *PartnerClient) Query() *PartnerQuery {
	return &PartnerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePartner},
		inters: c.Interceptors(),
	}
}

// Get returns a Partner entity by its id.
func (c *PartnerClient) Get(ctx context.Context, id string) (*Partner, error) {
	return c.Query().Where(partner.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartnerClient) GetX(ctx context.Context, id string) *Partner {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PartnerClient) Hooks() []Hook {
	return c.hooks.Partner
}

// Interceptors returns the client interceptors.
func (c *PartnerClient) Interceptors() []Interceptor {
	return c.inters.Partner
}

func (c *PartnerClient) mutate(ctx context.Context, m *PartnerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartnerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartnerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartnerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Partner mutation op: %q", m.Op())
	}
}

// PdfClient is a client for the Pdf schema.
type PdfClient struct {
	config
}

// NewPdfClient returns a client for the Pdf from the given config.
func NewPdfClient(c config) *PdfClient {
	return &PdfClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pdf.Hooks(f(g(h())))`.
func (c *PdfClient) Use(hooks ...Hook) {
	c.hooks.Pdf = append(c.hooks.Pdf, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pdf.Intercept(f(g(h())))`.
func (c *PdfClient) Intercept(interceptors ...Interceptor) {
	c.inters.Pdf = append(c.inters.Pdf, interceptors...)
}

// Create returns a builder for creating a Pdf entity.
func (c *PdfClient) Create() *PdfCreate {
	mutation := newPdfMutation(c.config, OpCreate)
	return &PdfCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Pdf entities.
func (c *PdfClient) CreateBulk(builders ...*PdfCreate) *PdfCreateBulk {
	return &PdfCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PdfClient) MapCreateBulk(slice any, setFunc func(*PdfCreate, int)) *PdfCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PdfCreateBulk{err: fmt.Errorf("calling to PdfClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PdfCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PdfCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Pdf.
func (c *PdfClient) Update() *PdfUpdate {
	mutation := newPdfMutation(c.config, OpUpdate)
	return &PdfUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PdfClient) UpdateOne(pd *Pdf) *PdfUpdateOne {
	mutation := newPdfMutation(c.config, OpUpdateOne, withPdf(pd))
	return &PdfUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PdfClient) UpdateOneID(id int32) *PdfUpdateOne {
	mutation := newPdfMutation(c.config, OpUpdateOne, withPdfID(id))
	return &PdfUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Pdf.
func (c *PdfClient) Delete() *PdfDelete {
	mutation := newPdfMutation(c.config, OpDelete)
	return &PdfDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PdfClient) DeleteOne(pd *Pdf) *PdfDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PdfClient) DeleteOneID(id int32) *PdfDeleteOne {
	builder := c.Delete().Where(pdf.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PdfDeleteOne{builder}
}

// Query returns a query builder for Pdf.
func (c *PdfClient) Query() *PdfQuery {
	return &PdfQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePdf},
		inters: c.Interceptors(),
	}
}

// Get returns a Pdf entity by its id.
func (c *PdfClient) Get(ctx context.Context, id int32) (*Pdf, error) {
	return c.Query().Where(pdf.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PdfClient) GetX(ctx context.Context, id int32) *Pdf {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PdfClient) Hooks() []Hook {
	return c.hooks.Pdf
}

// Interceptors returns the client interceptors.
func (c *PdfClient) Interceptors() []Interceptor {
	return c.inters.Pdf
}

func (c *PdfClient) mutate(ctx context.Context, m *PdfMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PdfCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PdfUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PdfUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PdfDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Pdf mutation op: %q", m.Op())
	}
}

// StatuClient is a client for the Statu schema.
type StatuClient struct {
	config
}

// NewStatuClient returns a client for the Statu from the given config.
func NewStatuClient(c config) *StatuClient {
	return &StatuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statu.Hooks(f(g(h())))`.
func (c *StatuClient) Use(hooks ...Hook) {
	c.hooks.Statu = append(c.hooks.Statu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statu.Intercept(f(g(h())))`.
func (c *StatuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Statu = append(c.inters.Statu, interceptors...)
}

// Create returns a builder for creating a Statu entity.
func (c *StatuClient) Create() *StatuCreate {
	mutation := newStatuMutation(c.config, OpCreate)
	return &StatuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Statu entities.
func (c *StatuClient) CreateBulk(builders ...*StatuCreate) *StatuCreateBulk {
	return &StatuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatuClient) MapCreateBulk(slice any, setFunc func(*StatuCreate, int)) *StatuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatuCreateBulk{err: fmt.Errorf("calling to StatuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Statu.
func (c *StatuClient) Update() *StatuUpdate {
	mutation := newStatuMutation(c.config, OpUpdate)
	return &StatuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatuClient) UpdateOne(s *Statu) *StatuUpdateOne {
	mutation := newStatuMutation(c.config, OpUpdateOne, withStatu(s))
	return &StatuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatuClient) UpdateOneID(id int32) *StatuUpdateOne {
	mutation := newStatuMutation(c.config, OpUpdateOne, withStatuID(id))
	return &StatuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Statu.
func (c *StatuClient) Delete() *StatuDelete {
	mutation := newStatuMutation(c.config, OpDelete)
	return &StatuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatuClient) DeleteOne(s *Statu) *StatuDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatuClient) DeleteOneID(id int32) *StatuDeleteOne {
	builder := c.Delete().Where(statu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatuDeleteOne{builder}
}

// Query returns a query builder for Statu.
func (c *StatuClient) Query() *StatuQuery {
	return &StatuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatu},
		inters: c.Interceptors(),
	}
}

// Get returns a Statu entity by its id.
func (c *StatuClient) Get(ctx context.Context, id int32) (*Statu, error) {
	return c.Query().Where(statu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatuClient) GetX(ctx context.Context, id int32) *Statu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatuClient) Hooks() []Hook {
	return c.hooks.Statu
}

// Interceptors returns the client interceptors.
func (c *StatuClient) Interceptors() []Interceptor {
	return c.inters.Statu
}

func (c *StatuClient) mutate(ctx context.Context, m *StatuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Statu mutation op: %q", m.Op())
	}
}

// WarenlieferungClient is a client for the Warenlieferung schema.
type WarenlieferungClient struct {
	config
}

// NewWarenlieferungClient returns a client for the Warenlieferung from the given config.
func NewWarenlieferungClient(c config) *WarenlieferungClient {
	return &WarenlieferungClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `warenlieferung.Hooks(f(g(h())))`.
func (c *WarenlieferungClient) Use(hooks ...Hook) {
	c.hooks.Warenlieferung = append(c.hooks.Warenlieferung, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `warenlieferung.Intercept(f(g(h())))`.
func (c *WarenlieferungClient) Intercept(interceptors ...Interceptor) {
	c.inters.Warenlieferung = append(c.inters.Warenlieferung, interceptors...)
}

// Create returns a builder for creating a Warenlieferung entity.
func (c *WarenlieferungClient) Create() *WarenlieferungCreate {
	mutation := newWarenlieferungMutation(c.config, OpCreate)
	return &WarenlieferungCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Warenlieferung entities.
func (c *WarenlieferungClient) CreateBulk(builders ...*WarenlieferungCreate) *WarenlieferungCreateBulk {
	return &WarenlieferungCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WarenlieferungClient) MapCreateBulk(slice any, setFunc func(*WarenlieferungCreate, int)) *WarenlieferungCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WarenlieferungCreateBulk{err: fmt.Errorf("calling to WarenlieferungClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WarenlieferungCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WarenlieferungCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Warenlieferung.
func (c *WarenlieferungClient) Update() *WarenlieferungUpdate {
	mutation := newWarenlieferungMutation(c.config, OpUpdate)
	return &WarenlieferungUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WarenlieferungClient) UpdateOne(w *Warenlieferung) *WarenlieferungUpdateOne {
	mutation := newWarenlieferungMutation(c.config, OpUpdateOne, withWarenlieferung(w))
	return &WarenlieferungUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WarenlieferungClient) UpdateOneID(id int32) *WarenlieferungUpdateOne {
	mutation := newWarenlieferungMutation(c.config, OpUpdateOne, withWarenlieferungID(id))
	return &WarenlieferungUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Warenlieferung.
func (c *WarenlieferungClient) Delete() *WarenlieferungDelete {
	mutation := newWarenlieferungMutation(c.config, OpDelete)
	return &WarenlieferungDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WarenlieferungClient) DeleteOne(w *Warenlieferung) *WarenlieferungDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WarenlieferungClient) DeleteOneID(id int32) *WarenlieferungDeleteOne {
	builder := c.Delete().Where(warenlieferung.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WarenlieferungDeleteOne{builder}
}

// Query returns a query builder for Warenlieferung.
func (c *WarenlieferungClient) Query() *WarenlieferungQuery {
	return &WarenlieferungQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWarenlieferung},
		inters: c.Interceptors(),
	}
}

// Get returns a Warenlieferung entity by its id.
func (c *WarenlieferungClient) Get(ctx context.Context, id int32) (*Warenlieferung, error) {
	return c.Query().Where(warenlieferung.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WarenlieferungClient) GetX(ctx context.Context, id int32) *Warenlieferung {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WarenlieferungClient) Hooks() []Hook {
	return c.hooks.Warenlieferung
}

// Interceptors returns the client interceptors.
func (c *WarenlieferungClient) Interceptors() []Interceptor {
	return c.inters.Warenlieferung
}

func (c *WarenlieferungClient) mutate(ctx context.Context, m *WarenlieferungMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WarenlieferungCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WarenlieferungUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WarenlieferungUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WarenlieferungDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Warenlieferung mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Abteilung, Angebot, Ansprechpartner, Aussteller, Einkauf, Job, Lieferant,
		Mitarbeiter, Partner, Pdf, Statu, Warenlieferung []ent.Hook
	}
	inters struct {
		Abteilung, Angebot, Ansprechpartner, Aussteller, Einkauf, Job, Lieferant,
		Mitarbeiter, Partner, Pdf, Statu, Warenlieferung []ent.Interceptor
	}
)
