// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"viktor/ent/abteilung"
	"viktor/ent/angebot"
	"viktor/ent/ansprechpartner"
	"viktor/ent/aussteller"
	"viktor/ent/einkauf"
	"viktor/ent/job"
	"viktor/ent/lieferant"
	"viktor/ent/mitarbeiter"
	"viktor/ent/partner"
	"viktor/ent/pdf"
	"viktor/ent/predicate"
	"viktor/ent/statu"
	"viktor/ent/warenlieferung"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbteilung       = "Abteilung"
	TypeAngebot         = "Angebot"
	TypeAnsprechpartner = "Ansprechpartner"
	TypeAussteller      = "Aussteller"
	TypeEinkauf         = "Einkauf"
	TypeJob             = "Job"
	TypeLieferant       = "Lieferant"
	TypeMitarbeiter     = "Mitarbeiter"
	TypePartner         = "Partner"
	TypePdf             = "Pdf"
	TypeStatu           = "Statu"
	TypeWarenlieferung  = "Warenlieferung"
)

// AbteilungMutation represents an operation that mutates the Abteilung nodes in the graph.
type AbteilungMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	clearedFields       map[string]struct{}
	mitarbeiters        map[string]struct{}
	removedmitarbeiters map[string]struct{}
	clearedmitarbeiters bool
	done                bool
	oldValue            func(context.Context) (*Abteilung, error)
	predicates          []predicate.Abteilung
}

var _ ent.Mutation = (*AbteilungMutation)(nil)

// abteilungOption allows management of the mutation configuration using functional options.
type abteilungOption func(*AbteilungMutation)

// newAbteilungMutation creates new mutation for the Abteilung entity.
func newAbteilungMutation(c config, op Op, opts ...abteilungOption) *AbteilungMutation {
	m := &AbteilungMutation{
		config:        c,
		op:            op,
		typ:           TypeAbteilung,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbteilungID sets the ID field of the mutation.
func withAbteilungID(id string) abteilungOption {
	return func(m *AbteilungMutation) {
		var (
			err   error
			once  sync.Once
			value *Abteilung
		)
		m.oldValue = func(ctx context.Context) (*Abteilung, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abteilung.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbteilung sets the old Abteilung of the mutation.
func withAbteilung(node *Abteilung) abteilungOption {
	return func(m *AbteilungMutation) {
		m.oldValue = func(context.Context) (*Abteilung, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbteilungMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbteilungMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Abteilung entities.
func (m *AbteilungMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbteilungMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbteilungMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Abteilung.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AbteilungMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbteilungMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Abteilung entity.
// If the Abteilung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbteilungMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbteilungMutation) ResetName() {
	m.name = nil
}

// AddMitarbeiterIDs adds the "mitarbeiters" edge to the Mitarbeiter entity by ids.
func (m *AbteilungMutation) AddMitarbeiterIDs(ids ...string) {
	if m.mitarbeiters == nil {
		m.mitarbeiters = make(map[string]struct{})
	}
	for i := range ids {
		m.mitarbeiters[ids[i]] = struct{}{}
	}
}

// ClearMitarbeiters clears the "mitarbeiters" edge to the Mitarbeiter entity.
func (m *AbteilungMutation) ClearMitarbeiters() {
	m.clearedmitarbeiters = true
}

// MitarbeitersCleared reports if the "mitarbeiters" edge to the Mitarbeiter entity was cleared.
func (m *AbteilungMutation) MitarbeitersCleared() bool {
	return m.clearedmitarbeiters
}

// RemoveMitarbeiterIDs removes the "mitarbeiters" edge to the Mitarbeiter entity by IDs.
func (m *AbteilungMutation) RemoveMitarbeiterIDs(ids ...string) {
	if m.removedmitarbeiters == nil {
		m.removedmitarbeiters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mitarbeiters, ids[i])
		m.removedmitarbeiters[ids[i]] = struct{}{}
	}
}

// RemovedMitarbeiters returns the removed IDs of the "mitarbeiters" edge to the Mitarbeiter entity.
func (m *AbteilungMutation) RemovedMitarbeitersIDs() (ids []string) {
	for id := range m.removedmitarbeiters {
		ids = append(ids, id)
	}
	return
}

// MitarbeitersIDs returns the "mitarbeiters" edge IDs in the mutation.
func (m *AbteilungMutation) MitarbeitersIDs() (ids []string) {
	for id := range m.mitarbeiters {
		ids = append(ids, id)
	}
	return
}

// ResetMitarbeiters resets all changes to the "mitarbeiters" edge.
func (m *AbteilungMutation) ResetMitarbeiters() {
	m.mitarbeiters = nil
	m.clearedmitarbeiters = false
	m.removedmitarbeiters = nil
}

// Where appends a list predicates to the AbteilungMutation builder.
func (m *AbteilungMutation) Where(ps ...predicate.Abteilung) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbteilungMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbteilungMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Abteilung, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbteilungMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbteilungMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Abteilung).
func (m *AbteilungMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbteilungMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, abteilung.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbteilungMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abteilung.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbteilungMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abteilung.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Abteilung field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbteilungMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abteilung.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Abteilung field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbteilungMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbteilungMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbteilungMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Abteilung numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbteilungMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbteilungMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbteilungMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Abteilung nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbteilungMutation) ResetField(name string) error {
	switch name {
	case abteilung.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Abteilung field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbteilungMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.mitarbeiters != nil {
		edges = append(edges, abteilung.EdgeMitarbeiters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbteilungMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abteilung.EdgeMitarbeiters:
		ids := make([]ent.Value, 0, len(m.mitarbeiters))
		for id := range m.mitarbeiters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbteilungMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmitarbeiters != nil {
		edges = append(edges, abteilung.EdgeMitarbeiters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbteilungMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abteilung.EdgeMitarbeiters:
		ids := make([]ent.Value, 0, len(m.removedmitarbeiters))
		for id := range m.removedmitarbeiters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbteilungMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmitarbeiters {
		edges = append(edges, abteilung.EdgeMitarbeiters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbteilungMutation) EdgeCleared(name string) bool {
	switch name {
	case abteilung.EdgeMitarbeiters:
		return m.clearedmitarbeiters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbteilungMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Abteilung unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbteilungMutation) ResetEdge(name string) error {
	switch name {
	case abteilung.EdgeMitarbeiters:
		m.ResetMitarbeiters()
		return nil
	}
	return fmt.Errorf("unknown Abteilung edge %s", name)
}

// AngebotMutation represents an operation that mutates the Angebot nodes in the graph.
type AngebotMutation struct {
	config
	op            Op
	typ           string
	id            *string
	title         *string
	subtitle      *string
	date_start    *time.Time
	date_stop     *time.Time
	link          *string
	image         *string
	anzeigen      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Angebot, error)
	predicates    []predicate.Angebot
}

var _ ent.Mutation = (*AngebotMutation)(nil)

// angebotOption allows management of the mutation configuration using functional options.
type angebotOption func(*AngebotMutation)

// newAngebotMutation creates new mutation for the Angebot entity.
func newAngebotMutation(c config, op Op, opts ...angebotOption) *AngebotMutation {
	m := &AngebotMutation{
		config:        c,
		op:            op,
		typ:           TypeAngebot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAngebotID sets the ID field of the mutation.
func withAngebotID(id string) angebotOption {
	return func(m *AngebotMutation) {
		var (
			err   error
			once  sync.Once
			value *Angebot
		)
		m.oldValue = func(ctx context.Context) (*Angebot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Angebot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAngebot sets the old Angebot of the mutation.
func withAngebot(node *Angebot) angebotOption {
	return func(m *AngebotMutation) {
		m.oldValue = func(context.Context) (*Angebot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AngebotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AngebotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Angebot entities.
func (m *AngebotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AngebotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AngebotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Angebot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *AngebotMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AngebotMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AngebotMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *AngebotMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *AngebotMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ClearSubtitle clears the value of the "subtitle" field.
func (m *AngebotMutation) ClearSubtitle() {
	m.subtitle = nil
	m.clearedFields[angebot.FieldSubtitle] = struct{}{}
}

// SubtitleCleared returns if the "subtitle" field was cleared in this mutation.
func (m *AngebotMutation) SubtitleCleared() bool {
	_, ok := m.clearedFields[angebot.FieldSubtitle]
	return ok
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *AngebotMutation) ResetSubtitle() {
	m.subtitle = nil
	delete(m.clearedFields, angebot.FieldSubtitle)
}

// SetDateStart sets the "date_start" field.
func (m *AngebotMutation) SetDateStart(t time.Time) {
	m.date_start = &t
}

// DateStart returns the value of the "date_start" field in the mutation.
func (m *AngebotMutation) DateStart() (r time.Time, exists bool) {
	v := m.date_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDateStart returns the old "date_start" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldDateStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateStart: %w", err)
	}
	return oldValue.DateStart, nil
}

// ResetDateStart resets all changes to the "date_start" field.
func (m *AngebotMutation) ResetDateStart() {
	m.date_start = nil
}

// SetDateStop sets the "date_stop" field.
func (m *AngebotMutation) SetDateStop(t time.Time) {
	m.date_stop = &t
}

// DateStop returns the value of the "date_stop" field in the mutation.
func (m *AngebotMutation) DateStop() (r time.Time, exists bool) {
	v := m.date_stop
	if v == nil {
		return
	}
	return *v, true
}

// OldDateStop returns the old "date_stop" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldDateStop(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateStop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateStop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateStop: %w", err)
	}
	return oldValue.DateStop, nil
}

// ResetDateStop resets all changes to the "date_stop" field.
func (m *AngebotMutation) ResetDateStop() {
	m.date_stop = nil
}

// SetLink sets the "link" field.
func (m *AngebotMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *AngebotMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *AngebotMutation) ResetLink() {
	m.link = nil
}

// SetImage sets the "image" field.
func (m *AngebotMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *AngebotMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *AngebotMutation) ResetImage() {
	m.image = nil
}

// SetAnzeigen sets the "anzeigen" field.
func (m *AngebotMutation) SetAnzeigen(b bool) {
	m.anzeigen = &b
}

// Anzeigen returns the value of the "anzeigen" field in the mutation.
func (m *AngebotMutation) Anzeigen() (r bool, exists bool) {
	v := m.anzeigen
	if v == nil {
		return
	}
	return *v, true
}

// OldAnzeigen returns the old "anzeigen" field's value of the Angebot entity.
// If the Angebot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AngebotMutation) OldAnzeigen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnzeigen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnzeigen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnzeigen: %w", err)
	}
	return oldValue.Anzeigen, nil
}

// ResetAnzeigen resets all changes to the "anzeigen" field.
func (m *AngebotMutation) ResetAnzeigen() {
	m.anzeigen = nil
}

// Where appends a list predicates to the AngebotMutation builder.
func (m *AngebotMutation) Where(ps ...predicate.Angebot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AngebotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AngebotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Angebot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AngebotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AngebotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Angebot).
func (m *AngebotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AngebotMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, angebot.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, angebot.FieldSubtitle)
	}
	if m.date_start != nil {
		fields = append(fields, angebot.FieldDateStart)
	}
	if m.date_stop != nil {
		fields = append(fields, angebot.FieldDateStop)
	}
	if m.link != nil {
		fields = append(fields, angebot.FieldLink)
	}
	if m.image != nil {
		fields = append(fields, angebot.FieldImage)
	}
	if m.anzeigen != nil {
		fields = append(fields, angebot.FieldAnzeigen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AngebotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case angebot.FieldTitle:
		return m.Title()
	case angebot.FieldSubtitle:
		return m.Subtitle()
	case angebot.FieldDateStart:
		return m.DateStart()
	case angebot.FieldDateStop:
		return m.DateStop()
	case angebot.FieldLink:
		return m.Link()
	case angebot.FieldImage:
		return m.Image()
	case angebot.FieldAnzeigen:
		return m.Anzeigen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AngebotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case angebot.FieldTitle:
		return m.OldTitle(ctx)
	case angebot.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case angebot.FieldDateStart:
		return m.OldDateStart(ctx)
	case angebot.FieldDateStop:
		return m.OldDateStop(ctx)
	case angebot.FieldLink:
		return m.OldLink(ctx)
	case angebot.FieldImage:
		return m.OldImage(ctx)
	case angebot.FieldAnzeigen:
		return m.OldAnzeigen(ctx)
	}
	return nil, fmt.Errorf("unknown Angebot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AngebotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case angebot.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case angebot.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case angebot.FieldDateStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateStart(v)
		return nil
	case angebot.FieldDateStop:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateStop(v)
		return nil
	case angebot.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case angebot.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case angebot.FieldAnzeigen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnzeigen(v)
		return nil
	}
	return fmt.Errorf("unknown Angebot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AngebotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AngebotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AngebotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Angebot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AngebotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(angebot.FieldSubtitle) {
		fields = append(fields, angebot.FieldSubtitle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AngebotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AngebotMutation) ClearField(name string) error {
	switch name {
	case angebot.FieldSubtitle:
		m.ClearSubtitle()
		return nil
	}
	return fmt.Errorf("unknown Angebot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AngebotMutation) ResetField(name string) error {
	switch name {
	case angebot.FieldTitle:
		m.ResetTitle()
		return nil
	case angebot.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case angebot.FieldDateStart:
		m.ResetDateStart()
		return nil
	case angebot.FieldDateStop:
		m.ResetDateStop()
		return nil
	case angebot.FieldLink:
		m.ResetLink()
		return nil
	case angebot.FieldImage:
		m.ResetImage()
		return nil
	case angebot.FieldAnzeigen:
		m.ResetAnzeigen()
		return nil
	}
	return fmt.Errorf("unknown Angebot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AngebotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AngebotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AngebotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AngebotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AngebotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AngebotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AngebotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Angebot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AngebotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Angebot edge %s", name)
}

// AnsprechpartnerMutation represents an operation that mutates the Ansprechpartner nodes in the graph.
type AnsprechpartnerMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	telefon          *string
	mobil            *string
	mail             *string
	clearedFields    map[string]struct{}
	lieferant        *string
	clearedlieferant bool
	done             bool
	oldValue         func(context.Context) (*Ansprechpartner, error)
	predicates       []predicate.Ansprechpartner
}

var _ ent.Mutation = (*AnsprechpartnerMutation)(nil)

// ansprechpartnerOption allows management of the mutation configuration using functional options.
type ansprechpartnerOption func(*AnsprechpartnerMutation)

// newAnsprechpartnerMutation creates new mutation for the Ansprechpartner entity.
func newAnsprechpartnerMutation(c config, op Op, opts ...ansprechpartnerOption) *AnsprechpartnerMutation {
	m := &AnsprechpartnerMutation{
		config:        c,
		op:            op,
		typ:           TypeAnsprechpartner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnsprechpartnerID sets the ID field of the mutation.
func withAnsprechpartnerID(id string) ansprechpartnerOption {
	return func(m *AnsprechpartnerMutation) {
		var (
			err   error
			once  sync.Once
			value *Ansprechpartner
		)
		m.oldValue = func(ctx context.Context) (*Ansprechpartner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ansprechpartner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnsprechpartner sets the old Ansprechpartner of the mutation.
func withAnsprechpartner(node *Ansprechpartner) ansprechpartnerOption {
	return func(m *AnsprechpartnerMutation) {
		m.oldValue = func(context.Context) (*Ansprechpartner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnsprechpartnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnsprechpartnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ansprechpartner entities.
func (m *AnsprechpartnerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnsprechpartnerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnsprechpartnerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ansprechpartner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AnsprechpartnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AnsprechpartnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AnsprechpartnerMutation) ResetName() {
	m.name = nil
}

// SetTelefon sets the "telefon" field.
func (m *AnsprechpartnerMutation) SetTelefon(s string) {
	m.telefon = &s
}

// Telefon returns the value of the "telefon" field in the mutation.
func (m *AnsprechpartnerMutation) Telefon() (r string, exists bool) {
	v := m.telefon
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefon returns the old "telefon" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldTelefon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefon: %w", err)
	}
	return oldValue.Telefon, nil
}

// ClearTelefon clears the value of the "telefon" field.
func (m *AnsprechpartnerMutation) ClearTelefon() {
	m.telefon = nil
	m.clearedFields[ansprechpartner.FieldTelefon] = struct{}{}
}

// TelefonCleared returns if the "telefon" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) TelefonCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldTelefon]
	return ok
}

// ResetTelefon resets all changes to the "telefon" field.
func (m *AnsprechpartnerMutation) ResetTelefon() {
	m.telefon = nil
	delete(m.clearedFields, ansprechpartner.FieldTelefon)
}

// SetMobil sets the "mobil" field.
func (m *AnsprechpartnerMutation) SetMobil(s string) {
	m.mobil = &s
}

// Mobil returns the value of the "mobil" field in the mutation.
func (m *AnsprechpartnerMutation) Mobil() (r string, exists bool) {
	v := m.mobil
	if v == nil {
		return
	}
	return *v, true
}

// OldMobil returns the old "mobil" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldMobil(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobil: %w", err)
	}
	return oldValue.Mobil, nil
}

// ClearMobil clears the value of the "mobil" field.
func (m *AnsprechpartnerMutation) ClearMobil() {
	m.mobil = nil
	m.clearedFields[ansprechpartner.FieldMobil] = struct{}{}
}

// MobilCleared returns if the "mobil" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) MobilCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldMobil]
	return ok
}

// ResetMobil resets all changes to the "mobil" field.
func (m *AnsprechpartnerMutation) ResetMobil() {
	m.mobil = nil
	delete(m.clearedFields, ansprechpartner.FieldMobil)
}

// SetMail sets the "mail" field.
func (m *AnsprechpartnerMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *AnsprechpartnerMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ClearMail clears the value of the "mail" field.
func (m *AnsprechpartnerMutation) ClearMail() {
	m.mail = nil
	m.clearedFields[ansprechpartner.FieldMail] = struct{}{}
}

// MailCleared returns if the "mail" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) MailCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldMail]
	return ok
}

// ResetMail resets all changes to the "mail" field.
func (m *AnsprechpartnerMutation) ResetMail() {
	m.mail = nil
	delete(m.clearedFields, ansprechpartner.FieldMail)
}

// SetLieferantId sets the "lieferantId" field.
func (m *AnsprechpartnerMutation) SetLieferantId(s string) {
	m.lieferant = &s
}

// LieferantId returns the value of the "lieferantId" field in the mutation.
func (m *AnsprechpartnerMutation) LieferantId() (r string, exists bool) {
	v := m.lieferant
	if v == nil {
		return
	}
	return *v, true
}

// OldLieferantId returns the old "lieferantId" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldLieferantId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLieferantId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLieferantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLieferantId: %w", err)
	}
	return oldValue.LieferantId, nil
}

// ClearLieferantId clears the value of the "lieferantId" field.
func (m *AnsprechpartnerMutation) ClearLieferantId() {
	m.lieferant = nil
	m.clearedFields[ansprechpartner.FieldLieferantId] = struct{}{}
}

// LieferantIdCleared returns if the "lieferantId" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) LieferantIdCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldLieferantId]
	return ok
}

// ResetLieferantId resets all changes to the "lieferantId" field.
func (m *AnsprechpartnerMutation) ResetLieferantId() {
	m.lieferant = nil
	delete(m.clearedFields, ansprechpartner.FieldLieferantId)
}

// SetLieferantID sets the "lieferant" edge to the Lieferant entity by id.
func (m *AnsprechpartnerMutation) SetLieferantID(id string) {
	m.lieferant = &id
}

// ClearLieferant clears the "lieferant" edge to the Lieferant entity.
func (m *AnsprechpartnerMutation) ClearLieferant() {
	m.clearedlieferant = true
	m.clearedFields[ansprechpartner.FieldLieferantId] = struct{}{}
}

// LieferantCleared reports if the "lieferant" edge to the Lieferant entity was cleared.
func (m *AnsprechpartnerMutation) LieferantCleared() bool {
	return m.LieferantIdCleared() || m.clearedlieferant
}

// LieferantID returns the "lieferant" edge ID in the mutation.
func (m *AnsprechpartnerMutation) LieferantID() (id string, exists bool) {
	if m.lieferant != nil {
		return *m.lieferant, true
	}
	return
}

// LieferantIDs returns the "lieferant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LieferantID instead. It exists only for internal usage by the builders.
func (m *AnsprechpartnerMutation) LieferantIDs() (ids []string) {
	if id := m.lieferant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLieferant resets all changes to the "lieferant" edge.
func (m *AnsprechpartnerMutation) ResetLieferant() {
	m.lieferant = nil
	m.clearedlieferant = false
}

// Where appends a list predicates to the AnsprechpartnerMutation builder.
func (m *AnsprechpartnerMutation) Where(ps ...predicate.Ansprechpartner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnsprechpartnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnsprechpartnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ansprechpartner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnsprechpartnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnsprechpartnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ansprechpartner).
func (m *AnsprechpartnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnsprechpartnerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, ansprechpartner.FieldName)
	}
	if m.telefon != nil {
		fields = append(fields, ansprechpartner.FieldTelefon)
	}
	if m.mobil != nil {
		fields = append(fields, ansprechpartner.FieldMobil)
	}
	if m.mail != nil {
		fields = append(fields, ansprechpartner.FieldMail)
	}
	if m.lieferant != nil {
		fields = append(fields, ansprechpartner.FieldLieferantId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnsprechpartnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ansprechpartner.FieldName:
		return m.Name()
	case ansprechpartner.FieldTelefon:
		return m.Telefon()
	case ansprechpartner.FieldMobil:
		return m.Mobil()
	case ansprechpartner.FieldMail:
		return m.Mail()
	case ansprechpartner.FieldLieferantId:
		return m.LieferantId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnsprechpartnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ansprechpartner.FieldName:
		return m.OldName(ctx)
	case ansprechpartner.FieldTelefon:
		return m.OldTelefon(ctx)
	case ansprechpartner.FieldMobil:
		return m.OldMobil(ctx)
	case ansprechpartner.FieldMail:
		return m.OldMail(ctx)
	case ansprechpartner.FieldLieferantId:
		return m.OldLieferantId(ctx)
	}
	return nil, fmt.Errorf("unknown Ansprechpartner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsprechpartnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ansprechpartner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ansprechpartner.FieldTelefon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefon(v)
		return nil
	case ansprechpartner.FieldMobil:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobil(v)
		return nil
	case ansprechpartner.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case ansprechpartner.FieldLieferantId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLieferantId(v)
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnsprechpartnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnsprechpartnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsprechpartnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ansprechpartner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnsprechpartnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ansprechpartner.FieldTelefon) {
		fields = append(fields, ansprechpartner.FieldTelefon)
	}
	if m.FieldCleared(ansprechpartner.FieldMobil) {
		fields = append(fields, ansprechpartner.FieldMobil)
	}
	if m.FieldCleared(ansprechpartner.FieldMail) {
		fields = append(fields, ansprechpartner.FieldMail)
	}
	if m.FieldCleared(ansprechpartner.FieldLieferantId) {
		fields = append(fields, ansprechpartner.FieldLieferantId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnsprechpartnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnsprechpartnerMutation) ClearField(name string) error {
	switch name {
	case ansprechpartner.FieldTelefon:
		m.ClearTelefon()
		return nil
	case ansprechpartner.FieldMobil:
		m.ClearMobil()
		return nil
	case ansprechpartner.FieldMail:
		m.ClearMail()
		return nil
	case ansprechpartner.FieldLieferantId:
		m.ClearLieferantId()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnsprechpartnerMutation) ResetField(name string) error {
	switch name {
	case ansprechpartner.FieldName:
		m.ResetName()
		return nil
	case ansprechpartner.FieldTelefon:
		m.ResetTelefon()
		return nil
	case ansprechpartner.FieldMobil:
		m.ResetMobil()
		return nil
	case ansprechpartner.FieldMail:
		m.ResetMail()
		return nil
	case ansprechpartner.FieldLieferantId:
		m.ResetLieferantId()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnsprechpartnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lieferant != nil {
		edges = append(edges, ansprechpartner.EdgeLieferant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnsprechpartnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ansprechpartner.EdgeLieferant:
		if id := m.lieferant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnsprechpartnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnsprechpartnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnsprechpartnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlieferant {
		edges = append(edges, ansprechpartner.EdgeLieferant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnsprechpartnerMutation) EdgeCleared(name string) bool {
	switch name {
	case ansprechpartner.EdgeLieferant:
		return m.clearedlieferant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnsprechpartnerMutation) ClearEdge(name string) error {
	switch name {
	case ansprechpartner.EdgeLieferant:
		m.ClearLieferant()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnsprechpartnerMutation) ResetEdge(name string) error {
	switch name {
	case ansprechpartner.EdgeLieferant:
		m.ResetLieferant()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner edge %s", name)
}

// AusstellerMutation represents an operation that mutates the Aussteller nodes in the graph.
type AusstellerMutation struct {
	config
	op             Op
	typ            string
	id             *int32
	_Artikelnummer *string
	_Artikelname   *string
	_Specs         *string
	_Preis         *float32
	add_Preis      *float32
	_Bild          *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Aussteller, error)
	predicates     []predicate.Aussteller
}

var _ ent.Mutation = (*AusstellerMutation)(nil)

// ausstellerOption allows management of the mutation configuration using functional options.
type ausstellerOption func(*AusstellerMutation)

// newAusstellerMutation creates new mutation for the Aussteller entity.
func newAusstellerMutation(c config, op Op, opts ...ausstellerOption) *AusstellerMutation {
	m := &AusstellerMutation{
		config:        c,
		op:            op,
		typ:           TypeAussteller,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAusstellerID sets the ID field of the mutation.
func withAusstellerID(id int32) ausstellerOption {
	return func(m *AusstellerMutation) {
		var (
			err   error
			once  sync.Once
			value *Aussteller
		)
		m.oldValue = func(ctx context.Context) (*Aussteller, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Aussteller.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAussteller sets the old Aussteller of the mutation.
func withAussteller(node *Aussteller) ausstellerOption {
	return func(m *AusstellerMutation) {
		m.oldValue = func(context.Context) (*Aussteller, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AusstellerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AusstellerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Aussteller entities.
func (m *AusstellerMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AusstellerMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AusstellerMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Aussteller.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtikelnummer sets the "Artikelnummer" field.
func (m *AusstellerMutation) SetArtikelnummer(s string) {
	m._Artikelnummer = &s
}

// Artikelnummer returns the value of the "Artikelnummer" field in the mutation.
func (m *AusstellerMutation) Artikelnummer() (r string, exists bool) {
	v := m._Artikelnummer
	if v == nil {
		return
	}
	return *v, true
}

// OldArtikelnummer returns the old "Artikelnummer" field's value of the Aussteller entity.
// If the Aussteller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AusstellerMutation) OldArtikelnummer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtikelnummer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtikelnummer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtikelnummer: %w", err)
	}
	return oldValue.Artikelnummer, nil
}

// ResetArtikelnummer resets all changes to the "Artikelnummer" field.
func (m *AusstellerMutation) ResetArtikelnummer() {
	m._Artikelnummer = nil
}

// SetArtikelname sets the "Artikelname" field.
func (m *AusstellerMutation) SetArtikelname(s string) {
	m._Artikelname = &s
}

// Artikelname returns the value of the "Artikelname" field in the mutation.
func (m *AusstellerMutation) Artikelname() (r string, exists bool) {
	v := m._Artikelname
	if v == nil {
		return
	}
	return *v, true
}

// OldArtikelname returns the old "Artikelname" field's value of the Aussteller entity.
// If the Aussteller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AusstellerMutation) OldArtikelname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtikelname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtikelname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtikelname: %w", err)
	}
	return oldValue.Artikelname, nil
}

// ResetArtikelname resets all changes to the "Artikelname" field.
func (m *AusstellerMutation) ResetArtikelname() {
	m._Artikelname = nil
}

// SetSpecs sets the "Specs" field.
func (m *AusstellerMutation) SetSpecs(s string) {
	m._Specs = &s
}

// Specs returns the value of the "Specs" field in the mutation.
func (m *AusstellerMutation) Specs() (r string, exists bool) {
	v := m._Specs
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecs returns the old "Specs" field's value of the Aussteller entity.
// If the Aussteller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AusstellerMutation) OldSpecs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecs: %w", err)
	}
	return oldValue.Specs, nil
}

// ResetSpecs resets all changes to the "Specs" field.
func (m *AusstellerMutation) ResetSpecs() {
	m._Specs = nil
}

// SetPreis sets the "Preis" field.
func (m *AusstellerMutation) SetPreis(f float32) {
	m._Preis = &f
	m.add_Preis = nil
}

// Preis returns the value of the "Preis" field in the mutation.
func (m *AusstellerMutation) Preis() (r float32, exists bool) {
	v := m._Preis
	if v == nil {
		return
	}
	return *v, true
}

// OldPreis returns the old "Preis" field's value of the Aussteller entity.
// If the Aussteller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AusstellerMutation) OldPreis(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreis: %w", err)
	}
	return oldValue.Preis, nil
}

// AddPreis adds f to the "Preis" field.
func (m *AusstellerMutation) AddPreis(f float32) {
	if m.add_Preis != nil {
		*m.add_Preis += f
	} else {
		m.add_Preis = &f
	}
}

// AddedPreis returns the value that was added to the "Preis" field in this mutation.
func (m *AusstellerMutation) AddedPreis() (r float32, exists bool) {
	v := m.add_Preis
	if v == nil {
		return
	}
	return *v, true
}

// ResetPreis resets all changes to the "Preis" field.
func (m *AusstellerMutation) ResetPreis() {
	m._Preis = nil
	m.add_Preis = nil
}

// SetBild sets the "Bild" field.
func (m *AusstellerMutation) SetBild(s string) {
	m._Bild = &s
}

// Bild returns the value of the "Bild" field in the mutation.
func (m *AusstellerMutation) Bild() (r string, exists bool) {
	v := m._Bild
	if v == nil {
		return
	}
	return *v, true
}

// OldBild returns the old "Bild" field's value of the Aussteller entity.
// If the Aussteller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AusstellerMutation) OldBild(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild: %w", err)
	}
	return oldValue.Bild, nil
}

// ClearBild clears the value of the "Bild" field.
func (m *AusstellerMutation) ClearBild() {
	m._Bild = nil
	m.clearedFields[aussteller.FieldBild] = struct{}{}
}

// BildCleared returns if the "Bild" field was cleared in this mutation.
func (m *AusstellerMutation) BildCleared() bool {
	_, ok := m.clearedFields[aussteller.FieldBild]
	return ok
}

// ResetBild resets all changes to the "Bild" field.
func (m *AusstellerMutation) ResetBild() {
	m._Bild = nil
	delete(m.clearedFields, aussteller.FieldBild)
}

// Where appends a list predicates to the AusstellerMutation builder.
func (m *AusstellerMutation) Where(ps ...predicate.Aussteller) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AusstellerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AusstellerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Aussteller, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AusstellerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AusstellerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Aussteller).
func (m *AusstellerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AusstellerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._Artikelnummer != nil {
		fields = append(fields, aussteller.FieldArtikelnummer)
	}
	if m._Artikelname != nil {
		fields = append(fields, aussteller.FieldArtikelname)
	}
	if m._Specs != nil {
		fields = append(fields, aussteller.FieldSpecs)
	}
	if m._Preis != nil {
		fields = append(fields, aussteller.FieldPreis)
	}
	if m._Bild != nil {
		fields = append(fields, aussteller.FieldBild)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AusstellerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aussteller.FieldArtikelnummer:
		return m.Artikelnummer()
	case aussteller.FieldArtikelname:
		return m.Artikelname()
	case aussteller.FieldSpecs:
		return m.Specs()
	case aussteller.FieldPreis:
		return m.Preis()
	case aussteller.FieldBild:
		return m.Bild()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AusstellerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aussteller.FieldArtikelnummer:
		return m.OldArtikelnummer(ctx)
	case aussteller.FieldArtikelname:
		return m.OldArtikelname(ctx)
	case aussteller.FieldSpecs:
		return m.OldSpecs(ctx)
	case aussteller.FieldPreis:
		return m.OldPreis(ctx)
	case aussteller.FieldBild:
		return m.OldBild(ctx)
	}
	return nil, fmt.Errorf("unknown Aussteller field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AusstellerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aussteller.FieldArtikelnummer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtikelnummer(v)
		return nil
	case aussteller.FieldArtikelname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtikelname(v)
		return nil
	case aussteller.FieldSpecs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecs(v)
		return nil
	case aussteller.FieldPreis:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreis(v)
		return nil
	case aussteller.FieldBild:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild(v)
		return nil
	}
	return fmt.Errorf("unknown Aussteller field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AusstellerMutation) AddedFields() []string {
	var fields []string
	if m.add_Preis != nil {
		fields = append(fields, aussteller.FieldPreis)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AusstellerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case aussteller.FieldPreis:
		return m.AddedPreis()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AusstellerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case aussteller.FieldPreis:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreis(v)
		return nil
	}
	return fmt.Errorf("unknown Aussteller numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AusstellerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(aussteller.FieldBild) {
		fields = append(fields, aussteller.FieldBild)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AusstellerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AusstellerMutation) ClearField(name string) error {
	switch name {
	case aussteller.FieldBild:
		m.ClearBild()
		return nil
	}
	return fmt.Errorf("unknown Aussteller nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AusstellerMutation) ResetField(name string) error {
	switch name {
	case aussteller.FieldArtikelnummer:
		m.ResetArtikelnummer()
		return nil
	case aussteller.FieldArtikelname:
		m.ResetArtikelname()
		return nil
	case aussteller.FieldSpecs:
		m.ResetSpecs()
		return nil
	case aussteller.FieldPreis:
		m.ResetPreis()
		return nil
	case aussteller.FieldBild:
		m.ResetBild()
		return nil
	}
	return fmt.Errorf("unknown Aussteller field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AusstellerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AusstellerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AusstellerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AusstellerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AusstellerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AusstellerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AusstellerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Aussteller unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AusstellerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Aussteller edge %s", name)
}

// EinkaufMutation represents an operation that mutates the Einkauf nodes in the graph.
type EinkaufMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_Paypal            *bool
	_Abonniert         *bool
	_Geld              *string
	_Pfand             *string
	_Dinge             *string
	_Abgeschickt       *time.Time
	_Bild1             *string
	_Bild2             *string
	_Bild3             *string
	clearedFields      map[string]struct{}
	mitarbeiter        *string
	clearedmitarbeiter bool
	done               bool
	oldValue           func(context.Context) (*Einkauf, error)
	predicates         []predicate.Einkauf
}

var _ ent.Mutation = (*EinkaufMutation)(nil)

// einkaufOption allows management of the mutation configuration using functional options.
type einkaufOption func(*EinkaufMutation)

// newEinkaufMutation creates new mutation for the Einkauf entity.
func newEinkaufMutation(c config, op Op, opts ...einkaufOption) *EinkaufMutation {
	m := &EinkaufMutation{
		config:        c,
		op:            op,
		typ:           TypeEinkauf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEinkaufID sets the ID field of the mutation.
func withEinkaufID(id string) einkaufOption {
	return func(m *EinkaufMutation) {
		var (
			err   error
			once  sync.Once
			value *Einkauf
		)
		m.oldValue = func(ctx context.Context) (*Einkauf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Einkauf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEinkauf sets the old Einkauf of the mutation.
func withEinkauf(node *Einkauf) einkaufOption {
	return func(m *EinkaufMutation) {
		m.oldValue = func(context.Context) (*Einkauf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EinkaufMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EinkaufMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Einkauf entities.
func (m *EinkaufMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EinkaufMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EinkaufMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Einkauf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPaypal sets the "Paypal" field.
func (m *EinkaufMutation) SetPaypal(b bool) {
	m._Paypal = &b
}

// Paypal returns the value of the "Paypal" field in the mutation.
func (m *EinkaufMutation) Paypal() (r bool, exists bool) {
	v := m._Paypal
	if v == nil {
		return
	}
	return *v, true
}

// OldPaypal returns the old "Paypal" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldPaypal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaypal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaypal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaypal: %w", err)
	}
	return oldValue.Paypal, nil
}

// ResetPaypal resets all changes to the "Paypal" field.
func (m *EinkaufMutation) ResetPaypal() {
	m._Paypal = nil
}

// SetAbonniert sets the "Abonniert" field.
func (m *EinkaufMutation) SetAbonniert(b bool) {
	m._Abonniert = &b
}

// Abonniert returns the value of the "Abonniert" field in the mutation.
func (m *EinkaufMutation) Abonniert() (r bool, exists bool) {
	v := m._Abonniert
	if v == nil {
		return
	}
	return *v, true
}

// OldAbonniert returns the old "Abonniert" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldAbonniert(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbonniert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbonniert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbonniert: %w", err)
	}
	return oldValue.Abonniert, nil
}

// ResetAbonniert resets all changes to the "Abonniert" field.
func (m *EinkaufMutation) ResetAbonniert() {
	m._Abonniert = nil
}

// SetGeld sets the "Geld" field.
func (m *EinkaufMutation) SetGeld(s string) {
	m._Geld = &s
}

// Geld returns the value of the "Geld" field in the mutation.
func (m *EinkaufMutation) Geld() (r string, exists bool) {
	v := m._Geld
	if v == nil {
		return
	}
	return *v, true
}

// OldGeld returns the old "Geld" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldGeld(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeld: %w", err)
	}
	return oldValue.Geld, nil
}

// ClearGeld clears the value of the "Geld" field.
func (m *EinkaufMutation) ClearGeld() {
	m._Geld = nil
	m.clearedFields[einkauf.FieldGeld] = struct{}{}
}

// GeldCleared returns if the "Geld" field was cleared in this mutation.
func (m *EinkaufMutation) GeldCleared() bool {
	_, ok := m.clearedFields[einkauf.FieldGeld]
	return ok
}

// ResetGeld resets all changes to the "Geld" field.
func (m *EinkaufMutation) ResetGeld() {
	m._Geld = nil
	delete(m.clearedFields, einkauf.FieldGeld)
}

// SetPfand sets the "Pfand" field.
func (m *EinkaufMutation) SetPfand(s string) {
	m._Pfand = &s
}

// Pfand returns the value of the "Pfand" field in the mutation.
func (m *EinkaufMutation) Pfand() (r string, exists bool) {
	v := m._Pfand
	if v == nil {
		return
	}
	return *v, true
}

// OldPfand returns the old "Pfand" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldPfand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPfand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPfand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPfand: %w", err)
	}
	return oldValue.Pfand, nil
}

// ClearPfand clears the value of the "Pfand" field.
func (m *EinkaufMutation) ClearPfand() {
	m._Pfand = nil
	m.clearedFields[einkauf.FieldPfand] = struct{}{}
}

// PfandCleared returns if the "Pfand" field was cleared in this mutation.
func (m *EinkaufMutation) PfandCleared() bool {
	_, ok := m.clearedFields[einkauf.FieldPfand]
	return ok
}

// ResetPfand resets all changes to the "Pfand" field.
func (m *EinkaufMutation) ResetPfand() {
	m._Pfand = nil
	delete(m.clearedFields, einkauf.FieldPfand)
}

// SetDinge sets the "Dinge" field.
func (m *EinkaufMutation) SetDinge(s string) {
	m._Dinge = &s
}

// Dinge returns the value of the "Dinge" field in the mutation.
func (m *EinkaufMutation) Dinge() (r string, exists bool) {
	v := m._Dinge
	if v == nil {
		return
	}
	return *v, true
}

// OldDinge returns the old "Dinge" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldDinge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDinge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDinge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDinge: %w", err)
	}
	return oldValue.Dinge, nil
}

// ResetDinge resets all changes to the "Dinge" field.
func (m *EinkaufMutation) ResetDinge() {
	m._Dinge = nil
}

// SetAbgeschickt sets the "Abgeschickt" field.
func (m *EinkaufMutation) SetAbgeschickt(t time.Time) {
	m._Abgeschickt = &t
}

// Abgeschickt returns the value of the "Abgeschickt" field in the mutation.
func (m *EinkaufMutation) Abgeschickt() (r time.Time, exists bool) {
	v := m._Abgeschickt
	if v == nil {
		return
	}
	return *v, true
}

// OldAbgeschickt returns the old "Abgeschickt" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldAbgeschickt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbgeschickt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbgeschickt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbgeschickt: %w", err)
	}
	return oldValue.Abgeschickt, nil
}

// ResetAbgeschickt resets all changes to the "Abgeschickt" field.
func (m *EinkaufMutation) ResetAbgeschickt() {
	m._Abgeschickt = nil
}

// SetBild1 sets the "Bild1" field.
func (m *EinkaufMutation) SetBild1(s string) {
	m._Bild1 = &s
}

// Bild1 returns the value of the "Bild1" field in the mutation.
func (m *EinkaufMutation) Bild1() (r string, exists bool) {
	v := m._Bild1
	if v == nil {
		return
	}
	return *v, true
}

// OldBild1 returns the old "Bild1" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldBild1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild1: %w", err)
	}
	return oldValue.Bild1, nil
}

// ClearBild1 clears the value of the "Bild1" field.
func (m *EinkaufMutation) ClearBild1() {
	m._Bild1 = nil
	m.clearedFields[einkauf.FieldBild1] = struct{}{}
}

// Bild1Cleared returns if the "Bild1" field was cleared in this mutation.
func (m *EinkaufMutation) Bild1Cleared() bool {
	_, ok := m.clearedFields[einkauf.FieldBild1]
	return ok
}

// ResetBild1 resets all changes to the "Bild1" field.
func (m *EinkaufMutation) ResetBild1() {
	m._Bild1 = nil
	delete(m.clearedFields, einkauf.FieldBild1)
}

// SetBild2 sets the "Bild2" field.
func (m *EinkaufMutation) SetBild2(s string) {
	m._Bild2 = &s
}

// Bild2 returns the value of the "Bild2" field in the mutation.
func (m *EinkaufMutation) Bild2() (r string, exists bool) {
	v := m._Bild2
	if v == nil {
		return
	}
	return *v, true
}

// OldBild2 returns the old "Bild2" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldBild2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild2: %w", err)
	}
	return oldValue.Bild2, nil
}

// ClearBild2 clears the value of the "Bild2" field.
func (m *EinkaufMutation) ClearBild2() {
	m._Bild2 = nil
	m.clearedFields[einkauf.FieldBild2] = struct{}{}
}

// Bild2Cleared returns if the "Bild2" field was cleared in this mutation.
func (m *EinkaufMutation) Bild2Cleared() bool {
	_, ok := m.clearedFields[einkauf.FieldBild2]
	return ok
}

// ResetBild2 resets all changes to the "Bild2" field.
func (m *EinkaufMutation) ResetBild2() {
	m._Bild2 = nil
	delete(m.clearedFields, einkauf.FieldBild2)
}

// SetBild3 sets the "Bild3" field.
func (m *EinkaufMutation) SetBild3(s string) {
	m._Bild3 = &s
}

// Bild3 returns the value of the "Bild3" field in the mutation.
func (m *EinkaufMutation) Bild3() (r string, exists bool) {
	v := m._Bild3
	if v == nil {
		return
	}
	return *v, true
}

// OldBild3 returns the old "Bild3" field's value of the Einkauf entity.
// If the Einkauf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EinkaufMutation) OldBild3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild3: %w", err)
	}
	return oldValue.Bild3, nil
}

// ClearBild3 clears the value of the "Bild3" field.
func (m *EinkaufMutation) ClearBild3() {
	m._Bild3 = nil
	m.clearedFields[einkauf.FieldBild3] = struct{}{}
}

// Bild3Cleared returns if the "Bild3" field was cleared in this mutation.
func (m *EinkaufMutation) Bild3Cleared() bool {
	_, ok := m.clearedFields[einkauf.FieldBild3]
	return ok
}

// ResetBild3 resets all changes to the "Bild3" field.
func (m *EinkaufMutation) ResetBild3() {
	m._Bild3 = nil
	delete(m.clearedFields, einkauf.FieldBild3)
}

// SetMitarbeiterID sets the "mitarbeiter" edge to the Mitarbeiter entity by id.
func (m *EinkaufMutation) SetMitarbeiterID(id string) {
	m.mitarbeiter = &id
}

// ClearMitarbeiter clears the "mitarbeiter" edge to the Mitarbeiter entity.
func (m *EinkaufMutation) ClearMitarbeiter() {
	m.clearedmitarbeiter = true
}

// MitarbeiterCleared reports if the "mitarbeiter" edge to the Mitarbeiter entity was cleared.
func (m *EinkaufMutation) MitarbeiterCleared() bool {
	return m.clearedmitarbeiter
}

// MitarbeiterID returns the "mitarbeiter" edge ID in the mutation.
func (m *EinkaufMutation) MitarbeiterID() (id string, exists bool) {
	if m.mitarbeiter != nil {
		return *m.mitarbeiter, true
	}
	return
}

// MitarbeiterIDs returns the "mitarbeiter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MitarbeiterID instead. It exists only for internal usage by the builders.
func (m *EinkaufMutation) MitarbeiterIDs() (ids []string) {
	if id := m.mitarbeiter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMitarbeiter resets all changes to the "mitarbeiter" edge.
func (m *EinkaufMutation) ResetMitarbeiter() {
	m.mitarbeiter = nil
	m.clearedmitarbeiter = false
}

// Where appends a list predicates to the EinkaufMutation builder.
func (m *EinkaufMutation) Where(ps ...predicate.Einkauf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EinkaufMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EinkaufMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Einkauf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EinkaufMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EinkaufMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Einkauf).
func (m *EinkaufMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EinkaufMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._Paypal != nil {
		fields = append(fields, einkauf.FieldPaypal)
	}
	if m._Abonniert != nil {
		fields = append(fields, einkauf.FieldAbonniert)
	}
	if m._Geld != nil {
		fields = append(fields, einkauf.FieldGeld)
	}
	if m._Pfand != nil {
		fields = append(fields, einkauf.FieldPfand)
	}
	if m._Dinge != nil {
		fields = append(fields, einkauf.FieldDinge)
	}
	if m._Abgeschickt != nil {
		fields = append(fields, einkauf.FieldAbgeschickt)
	}
	if m._Bild1 != nil {
		fields = append(fields, einkauf.FieldBild1)
	}
	if m._Bild2 != nil {
		fields = append(fields, einkauf.FieldBild2)
	}
	if m._Bild3 != nil {
		fields = append(fields, einkauf.FieldBild3)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EinkaufMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case einkauf.FieldPaypal:
		return m.Paypal()
	case einkauf.FieldAbonniert:
		return m.Abonniert()
	case einkauf.FieldGeld:
		return m.Geld()
	case einkauf.FieldPfand:
		return m.Pfand()
	case einkauf.FieldDinge:
		return m.Dinge()
	case einkauf.FieldAbgeschickt:
		return m.Abgeschickt()
	case einkauf.FieldBild1:
		return m.Bild1()
	case einkauf.FieldBild2:
		return m.Bild2()
	case einkauf.FieldBild3:
		return m.Bild3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EinkaufMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case einkauf.FieldPaypal:
		return m.OldPaypal(ctx)
	case einkauf.FieldAbonniert:
		return m.OldAbonniert(ctx)
	case einkauf.FieldGeld:
		return m.OldGeld(ctx)
	case einkauf.FieldPfand:
		return m.OldPfand(ctx)
	case einkauf.FieldDinge:
		return m.OldDinge(ctx)
	case einkauf.FieldAbgeschickt:
		return m.OldAbgeschickt(ctx)
	case einkauf.FieldBild1:
		return m.OldBild1(ctx)
	case einkauf.FieldBild2:
		return m.OldBild2(ctx)
	case einkauf.FieldBild3:
		return m.OldBild3(ctx)
	}
	return nil, fmt.Errorf("unknown Einkauf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EinkaufMutation) SetField(name string, value ent.Value) error {
	switch name {
	case einkauf.FieldPaypal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaypal(v)
		return nil
	case einkauf.FieldAbonniert:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbonniert(v)
		return nil
	case einkauf.FieldGeld:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeld(v)
		return nil
	case einkauf.FieldPfand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPfand(v)
		return nil
	case einkauf.FieldDinge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDinge(v)
		return nil
	case einkauf.FieldAbgeschickt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbgeschickt(v)
		return nil
	case einkauf.FieldBild1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild1(v)
		return nil
	case einkauf.FieldBild2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild2(v)
		return nil
	case einkauf.FieldBild3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild3(v)
		return nil
	}
	return fmt.Errorf("unknown Einkauf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EinkaufMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EinkaufMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EinkaufMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Einkauf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EinkaufMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(einkauf.FieldGeld) {
		fields = append(fields, einkauf.FieldGeld)
	}
	if m.FieldCleared(einkauf.FieldPfand) {
		fields = append(fields, einkauf.FieldPfand)
	}
	if m.FieldCleared(einkauf.FieldBild1) {
		fields = append(fields, einkauf.FieldBild1)
	}
	if m.FieldCleared(einkauf.FieldBild2) {
		fields = append(fields, einkauf.FieldBild2)
	}
	if m.FieldCleared(einkauf.FieldBild3) {
		fields = append(fields, einkauf.FieldBild3)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EinkaufMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EinkaufMutation) ClearField(name string) error {
	switch name {
	case einkauf.FieldGeld:
		m.ClearGeld()
		return nil
	case einkauf.FieldPfand:
		m.ClearPfand()
		return nil
	case einkauf.FieldBild1:
		m.ClearBild1()
		return nil
	case einkauf.FieldBild2:
		m.ClearBild2()
		return nil
	case einkauf.FieldBild3:
		m.ClearBild3()
		return nil
	}
	return fmt.Errorf("unknown Einkauf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EinkaufMutation) ResetField(name string) error {
	switch name {
	case einkauf.FieldPaypal:
		m.ResetPaypal()
		return nil
	case einkauf.FieldAbonniert:
		m.ResetAbonniert()
		return nil
	case einkauf.FieldGeld:
		m.ResetGeld()
		return nil
	case einkauf.FieldPfand:
		m.ResetPfand()
		return nil
	case einkauf.FieldDinge:
		m.ResetDinge()
		return nil
	case einkauf.FieldAbgeschickt:
		m.ResetAbgeschickt()
		return nil
	case einkauf.FieldBild1:
		m.ResetBild1()
		return nil
	case einkauf.FieldBild2:
		m.ResetBild2()
		return nil
	case einkauf.FieldBild3:
		m.ResetBild3()
		return nil
	}
	return fmt.Errorf("unknown Einkauf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EinkaufMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.mitarbeiter != nil {
		edges = append(edges, einkauf.EdgeMitarbeiter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EinkaufMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case einkauf.EdgeMitarbeiter:
		if id := m.mitarbeiter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EinkaufMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EinkaufMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EinkaufMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmitarbeiter {
		edges = append(edges, einkauf.EdgeMitarbeiter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EinkaufMutation) EdgeCleared(name string) bool {
	switch name {
	case einkauf.EdgeMitarbeiter:
		return m.clearedmitarbeiter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EinkaufMutation) ClearEdge(name string) error {
	switch name {
	case einkauf.EdgeMitarbeiter:
		m.ClearMitarbeiter()
		return nil
	}
	return fmt.Errorf("unknown Einkauf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EinkaufMutation) ResetEdge(name string) error {
	switch name {
	case einkauf.EdgeMitarbeiter:
		m.ResetMitarbeiter()
		return nil
	}
	return fmt.Errorf("unknown Einkauf edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	online        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Job, error)
	predicates    []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id string) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *JobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobMutation) ResetName() {
	m.name = nil
}

// SetOnline sets the "online" field.
func (m *JobMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *JobMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ResetOnline resets all changes to the "online" field.
func (m *JobMutation) ResetOnline() {
	m.online = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, job.FieldName)
	}
	if m.online != nil {
		fields = append(fields, job.FieldOnline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldName:
		return m.Name()
	case job.FieldOnline:
		return m.Online()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldName:
		return m.OldName(ctx)
	case job.FieldOnline:
		return m.OldOnline(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case job.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldName:
		m.ResetName()
		return nil
	case job.FieldOnline:
		m.ResetOnline()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Job edge %s", name)
}

// LieferantMutation represents an operation that mutates the Lieferant nodes in the graph.
type LieferantMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	_Firma                  *string
	_Kundennummer           *string
	_Webseite               *string
	clearedFields           map[string]struct{}
	ansprechpartners        map[string]struct{}
	removedansprechpartners map[string]struct{}
	clearedansprechpartners bool
	done                    bool
	oldValue                func(context.Context) (*Lieferant, error)
	predicates              []predicate.Lieferant
}

var _ ent.Mutation = (*LieferantMutation)(nil)

// lieferantOption allows management of the mutation configuration using functional options.
type lieferantOption func(*LieferantMutation)

// newLieferantMutation creates new mutation for the Lieferant entity.
func newLieferantMutation(c config, op Op, opts ...lieferantOption) *LieferantMutation {
	m := &LieferantMutation{
		config:        c,
		op:            op,
		typ:           TypeLieferant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLieferantID sets the ID field of the mutation.
func withLieferantID(id string) lieferantOption {
	return func(m *LieferantMutation) {
		var (
			err   error
			once  sync.Once
			value *Lieferant
		)
		m.oldValue = func(ctx context.Context) (*Lieferant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lieferant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLieferant sets the old Lieferant of the mutation.
func withLieferant(node *Lieferant) lieferantOption {
	return func(m *LieferantMutation) {
		m.oldValue = func(context.Context) (*Lieferant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LieferantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LieferantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lieferant entities.
func (m *LieferantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LieferantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LieferantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lieferant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirma sets the "Firma" field.
func (m *LieferantMutation) SetFirma(s string) {
	m._Firma = &s
}

// Firma returns the value of the "Firma" field in the mutation.
func (m *LieferantMutation) Firma() (r string, exists bool) {
	v := m._Firma
	if v == nil {
		return
	}
	return *v, true
}

// OldFirma returns the old "Firma" field's value of the Lieferant entity.
// If the Lieferant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LieferantMutation) OldFirma(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirma is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirma requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirma: %w", err)
	}
	return oldValue.Firma, nil
}

// ResetFirma resets all changes to the "Firma" field.
func (m *LieferantMutation) ResetFirma() {
	m._Firma = nil
}

// SetKundennummer sets the "Kundennummer" field.
func (m *LieferantMutation) SetKundennummer(s string) {
	m._Kundennummer = &s
}

// Kundennummer returns the value of the "Kundennummer" field in the mutation.
func (m *LieferantMutation) Kundennummer() (r string, exists bool) {
	v := m._Kundennummer
	if v == nil {
		return
	}
	return *v, true
}

// OldKundennummer returns the old "Kundennummer" field's value of the Lieferant entity.
// If the Lieferant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LieferantMutation) OldKundennummer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKundennummer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKundennummer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKundennummer: %w", err)
	}
	return oldValue.Kundennummer, nil
}

// ClearKundennummer clears the value of the "Kundennummer" field.
func (m *LieferantMutation) ClearKundennummer() {
	m._Kundennummer = nil
	m.clearedFields[lieferant.FieldKundennummer] = struct{}{}
}

// KundennummerCleared returns if the "Kundennummer" field was cleared in this mutation.
func (m *LieferantMutation) KundennummerCleared() bool {
	_, ok := m.clearedFields[lieferant.FieldKundennummer]
	return ok
}

// ResetKundennummer resets all changes to the "Kundennummer" field.
func (m *LieferantMutation) ResetKundennummer() {
	m._Kundennummer = nil
	delete(m.clearedFields, lieferant.FieldKundennummer)
}

// SetWebseite sets the "Webseite" field.
func (m *LieferantMutation) SetWebseite(s string) {
	m._Webseite = &s
}

// Webseite returns the value of the "Webseite" field in the mutation.
func (m *LieferantMutation) Webseite() (r string, exists bool) {
	v := m._Webseite
	if v == nil {
		return
	}
	return *v, true
}

// OldWebseite returns the old "Webseite" field's value of the Lieferant entity.
// If the Lieferant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LieferantMutation) OldWebseite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebseite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebseite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebseite: %w", err)
	}
	return oldValue.Webseite, nil
}

// ClearWebseite clears the value of the "Webseite" field.
func (m *LieferantMutation) ClearWebseite() {
	m._Webseite = nil
	m.clearedFields[lieferant.FieldWebseite] = struct{}{}
}

// WebseiteCleared returns if the "Webseite" field was cleared in this mutation.
func (m *LieferantMutation) WebseiteCleared() bool {
	_, ok := m.clearedFields[lieferant.FieldWebseite]
	return ok
}

// ResetWebseite resets all changes to the "Webseite" field.
func (m *LieferantMutation) ResetWebseite() {
	m._Webseite = nil
	delete(m.clearedFields, lieferant.FieldWebseite)
}

// AddAnsprechpartnerIDs adds the "ansprechpartners" edge to the Ansprechpartner entity by ids.
func (m *LieferantMutation) AddAnsprechpartnerIDs(ids ...string) {
	if m.ansprechpartners == nil {
		m.ansprechpartners = make(map[string]struct{})
	}
	for i := range ids {
		m.ansprechpartners[ids[i]] = struct{}{}
	}
}

// ClearAnsprechpartners clears the "ansprechpartners" edge to the Ansprechpartner entity.
func (m *LieferantMutation) ClearAnsprechpartners() {
	m.clearedansprechpartners = true
}

// AnsprechpartnersCleared reports if the "ansprechpartners" edge to the Ansprechpartner entity was cleared.
func (m *LieferantMutation) AnsprechpartnersCleared() bool {
	return m.clearedansprechpartners
}

// RemoveAnsprechpartnerIDs removes the "ansprechpartners" edge to the Ansprechpartner entity by IDs.
func (m *LieferantMutation) RemoveAnsprechpartnerIDs(ids ...string) {
	if m.removedansprechpartners == nil {
		m.removedansprechpartners = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.ansprechpartners, ids[i])
		m.removedansprechpartners[ids[i]] = struct{}{}
	}
}

// RemovedAnsprechpartners returns the removed IDs of the "ansprechpartners" edge to the Ansprechpartner entity.
func (m *LieferantMutation) RemovedAnsprechpartnersIDs() (ids []string) {
	for id := range m.removedansprechpartners {
		ids = append(ids, id)
	}
	return
}

// AnsprechpartnersIDs returns the "ansprechpartners" edge IDs in the mutation.
func (m *LieferantMutation) AnsprechpartnersIDs() (ids []string) {
	for id := range m.ansprechpartners {
		ids = append(ids, id)
	}
	return
}

// ResetAnsprechpartners resets all changes to the "ansprechpartners" edge.
func (m *LieferantMutation) ResetAnsprechpartners() {
	m.ansprechpartners = nil
	m.clearedansprechpartners = false
	m.removedansprechpartners = nil
}

// Where appends a list predicates to the LieferantMutation builder.
func (m *LieferantMutation) Where(ps ...predicate.Lieferant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LieferantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LieferantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lieferant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LieferantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LieferantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lieferant).
func (m *LieferantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LieferantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Firma != nil {
		fields = append(fields, lieferant.FieldFirma)
	}
	if m._Kundennummer != nil {
		fields = append(fields, lieferant.FieldKundennummer)
	}
	if m._Webseite != nil {
		fields = append(fields, lieferant.FieldWebseite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LieferantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lieferant.FieldFirma:
		return m.Firma()
	case lieferant.FieldKundennummer:
		return m.Kundennummer()
	case lieferant.FieldWebseite:
		return m.Webseite()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LieferantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lieferant.FieldFirma:
		return m.OldFirma(ctx)
	case lieferant.FieldKundennummer:
		return m.OldKundennummer(ctx)
	case lieferant.FieldWebseite:
		return m.OldWebseite(ctx)
	}
	return nil, fmt.Errorf("unknown Lieferant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LieferantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lieferant.FieldFirma:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirma(v)
		return nil
	case lieferant.FieldKundennummer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKundennummer(v)
		return nil
	case lieferant.FieldWebseite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebseite(v)
		return nil
	}
	return fmt.Errorf("unknown Lieferant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LieferantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LieferantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LieferantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Lieferant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LieferantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lieferant.FieldKundennummer) {
		fields = append(fields, lieferant.FieldKundennummer)
	}
	if m.FieldCleared(lieferant.FieldWebseite) {
		fields = append(fields, lieferant.FieldWebseite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LieferantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LieferantMutation) ClearField(name string) error {
	switch name {
	case lieferant.FieldKundennummer:
		m.ClearKundennummer()
		return nil
	case lieferant.FieldWebseite:
		m.ClearWebseite()
		return nil
	}
	return fmt.Errorf("unknown Lieferant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LieferantMutation) ResetField(name string) error {
	switch name {
	case lieferant.FieldFirma:
		m.ResetFirma()
		return nil
	case lieferant.FieldKundennummer:
		m.ResetKundennummer()
		return nil
	case lieferant.FieldWebseite:
		m.ResetWebseite()
		return nil
	}
	return fmt.Errorf("unknown Lieferant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LieferantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ansprechpartners != nil {
		edges = append(edges, lieferant.EdgeAnsprechpartners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LieferantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lieferant.EdgeAnsprechpartners:
		ids := make([]ent.Value, 0, len(m.ansprechpartners))
		for id := range m.ansprechpartners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LieferantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedansprechpartners != nil {
		edges = append(edges, lieferant.EdgeAnsprechpartners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LieferantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lieferant.EdgeAnsprechpartners:
		ids := make([]ent.Value, 0, len(m.removedansprechpartners))
		for id := range m.removedansprechpartners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LieferantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedansprechpartners {
		edges = append(edges, lieferant.EdgeAnsprechpartners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LieferantMutation) EdgeCleared(name string) bool {
	switch name {
	case lieferant.EdgeAnsprechpartners:
		return m.clearedansprechpartners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LieferantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Lieferant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LieferantMutation) ResetEdge(name string) error {
	switch name {
	case lieferant.EdgeAnsprechpartners:
		m.ResetAnsprechpartners()
		return nil
	}
	return fmt.Errorf("unknown Lieferant edge %s", name)
}

// MitarbeiterMutation represents an operation that mutates the Mitarbeiter nodes in the graph.
type MitarbeiterMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	short             *string
	image             *bool
	sex               *string
	focus             *string
	mail              *string
	_Azubi            *bool
	_Geburtstag       *time.Time
	_Gruppenwahl      *string
	_HomeOffice       *string
	_Mobil_Business   *string
	_Mobil_Privat     *string
	_Telefon_Business *string
	_Telefon_Intern_1 *string
	_Telefon_Intern_2 *string
	_Telefon_Privat   *string
	clearedFields     map[string]struct{}
	abteilung         *string
	clearedabteilung  bool
	einkauf           *string
	clearedeinkauf    bool
	done              bool
	oldValue          func(context.Context) (*Mitarbeiter, error)
	predicates        []predicate.Mitarbeiter
}

var _ ent.Mutation = (*MitarbeiterMutation)(nil)

// mitarbeiterOption allows management of the mutation configuration using functional options.
type mitarbeiterOption func(*MitarbeiterMutation)

// newMitarbeiterMutation creates new mutation for the Mitarbeiter entity.
func newMitarbeiterMutation(c config, op Op, opts ...mitarbeiterOption) *MitarbeiterMutation {
	m := &MitarbeiterMutation{
		config:        c,
		op:            op,
		typ:           TypeMitarbeiter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMitarbeiterID sets the ID field of the mutation.
func withMitarbeiterID(id string) mitarbeiterOption {
	return func(m *MitarbeiterMutation) {
		var (
			err   error
			once  sync.Once
			value *Mitarbeiter
		)
		m.oldValue = func(ctx context.Context) (*Mitarbeiter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mitarbeiter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMitarbeiter sets the old Mitarbeiter of the mutation.
func withMitarbeiter(node *Mitarbeiter) mitarbeiterOption {
	return func(m *MitarbeiterMutation) {
		m.oldValue = func(context.Context) (*Mitarbeiter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MitarbeiterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MitarbeiterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mitarbeiter entities.
func (m *MitarbeiterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MitarbeiterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MitarbeiterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mitarbeiter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MitarbeiterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MitarbeiterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MitarbeiterMutation) ResetName() {
	m.name = nil
}

// SetShort sets the "short" field.
func (m *MitarbeiterMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *MitarbeiterMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ClearShort clears the value of the "short" field.
func (m *MitarbeiterMutation) ClearShort() {
	m.short = nil
	m.clearedFields[mitarbeiter.FieldShort] = struct{}{}
}

// ShortCleared returns if the "short" field was cleared in this mutation.
func (m *MitarbeiterMutation) ShortCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldShort]
	return ok
}

// ResetShort resets all changes to the "short" field.
func (m *MitarbeiterMutation) ResetShort() {
	m.short = nil
	delete(m.clearedFields, mitarbeiter.FieldShort)
}

// SetImage sets the "image" field.
func (m *MitarbeiterMutation) SetImage(b bool) {
	m.image = &b
}

// Image returns the value of the "image" field in the mutation.
func (m *MitarbeiterMutation) Image() (r bool, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldImage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *MitarbeiterMutation) ResetImage() {
	m.image = nil
}

// SetSex sets the "sex" field.
func (m *MitarbeiterMutation) SetSex(s string) {
	m.sex = &s
}

// Sex returns the value of the "sex" field in the mutation.
func (m *MitarbeiterMutation) Sex() (r string, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldSex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ClearSex clears the value of the "sex" field.
func (m *MitarbeiterMutation) ClearSex() {
	m.sex = nil
	m.clearedFields[mitarbeiter.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *MitarbeiterMutation) SexCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *MitarbeiterMutation) ResetSex() {
	m.sex = nil
	delete(m.clearedFields, mitarbeiter.FieldSex)
}

// SetFocus sets the "focus" field.
func (m *MitarbeiterMutation) SetFocus(s string) {
	m.focus = &s
}

// Focus returns the value of the "focus" field in the mutation.
func (m *MitarbeiterMutation) Focus() (r string, exists bool) {
	v := m.focus
	if v == nil {
		return
	}
	return *v, true
}

// OldFocus returns the old "focus" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldFocus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFocus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFocus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFocus: %w", err)
	}
	return oldValue.Focus, nil
}

// ClearFocus clears the value of the "focus" field.
func (m *MitarbeiterMutation) ClearFocus() {
	m.focus = nil
	m.clearedFields[mitarbeiter.FieldFocus] = struct{}{}
}

// FocusCleared returns if the "focus" field was cleared in this mutation.
func (m *MitarbeiterMutation) FocusCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldFocus]
	return ok
}

// ResetFocus resets all changes to the "focus" field.
func (m *MitarbeiterMutation) ResetFocus() {
	m.focus = nil
	delete(m.clearedFields, mitarbeiter.FieldFocus)
}

// SetMail sets the "mail" field.
func (m *MitarbeiterMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *MitarbeiterMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ClearMail clears the value of the "mail" field.
func (m *MitarbeiterMutation) ClearMail() {
	m.mail = nil
	m.clearedFields[mitarbeiter.FieldMail] = struct{}{}
}

// MailCleared returns if the "mail" field was cleared in this mutation.
func (m *MitarbeiterMutation) MailCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldMail]
	return ok
}

// ResetMail resets all changes to the "mail" field.
func (m *MitarbeiterMutation) ResetMail() {
	m.mail = nil
	delete(m.clearedFields, mitarbeiter.FieldMail)
}

// SetAbteilungId sets the "abteilungId" field.
func (m *MitarbeiterMutation) SetAbteilungId(s string) {
	m.abteilung = &s
}

// AbteilungId returns the value of the "abteilungId" field in the mutation.
func (m *MitarbeiterMutation) AbteilungId() (r string, exists bool) {
	v := m.abteilung
	if v == nil {
		return
	}
	return *v, true
}

// OldAbteilungId returns the old "abteilungId" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldAbteilungId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbteilungId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbteilungId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbteilungId: %w", err)
	}
	return oldValue.AbteilungId, nil
}

// ClearAbteilungId clears the value of the "abteilungId" field.
func (m *MitarbeiterMutation) ClearAbteilungId() {
	m.abteilung = nil
	m.clearedFields[mitarbeiter.FieldAbteilungId] = struct{}{}
}

// AbteilungIdCleared returns if the "abteilungId" field was cleared in this mutation.
func (m *MitarbeiterMutation) AbteilungIdCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldAbteilungId]
	return ok
}

// ResetAbteilungId resets all changes to the "abteilungId" field.
func (m *MitarbeiterMutation) ResetAbteilungId() {
	m.abteilung = nil
	delete(m.clearedFields, mitarbeiter.FieldAbteilungId)
}

// SetEinkaufId sets the "einkaufId" field.
func (m *MitarbeiterMutation) SetEinkaufId(s string) {
	m.einkauf = &s
}

// EinkaufId returns the value of the "einkaufId" field in the mutation.
func (m *MitarbeiterMutation) EinkaufId() (r string, exists bool) {
	v := m.einkauf
	if v == nil {
		return
	}
	return *v, true
}

// OldEinkaufId returns the old "einkaufId" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldEinkaufId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEinkaufId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEinkaufId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEinkaufId: %w", err)
	}
	return oldValue.EinkaufId, nil
}

// ClearEinkaufId clears the value of the "einkaufId" field.
func (m *MitarbeiterMutation) ClearEinkaufId() {
	m.einkauf = nil
	m.clearedFields[mitarbeiter.FieldEinkaufId] = struct{}{}
}

// EinkaufIdCleared returns if the "einkaufId" field was cleared in this mutation.
func (m *MitarbeiterMutation) EinkaufIdCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldEinkaufId]
	return ok
}

// ResetEinkaufId resets all changes to the "einkaufId" field.
func (m *MitarbeiterMutation) ResetEinkaufId() {
	m.einkauf = nil
	delete(m.clearedFields, mitarbeiter.FieldEinkaufId)
}

// SetAzubi sets the "Azubi" field.
func (m *MitarbeiterMutation) SetAzubi(b bool) {
	m._Azubi = &b
}

// Azubi returns the value of the "Azubi" field in the mutation.
func (m *MitarbeiterMutation) Azubi() (r bool, exists bool) {
	v := m._Azubi
	if v == nil {
		return
	}
	return *v, true
}

// OldAzubi returns the old "Azubi" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldAzubi(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAzubi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAzubi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAzubi: %w", err)
	}
	return oldValue.Azubi, nil
}

// ResetAzubi resets all changes to the "Azubi" field.
func (m *MitarbeiterMutation) ResetAzubi() {
	m._Azubi = nil
}

// SetGeburtstag sets the "Geburtstag" field.
func (m *MitarbeiterMutation) SetGeburtstag(t time.Time) {
	m._Geburtstag = &t
}

// Geburtstag returns the value of the "Geburtstag" field in the mutation.
func (m *MitarbeiterMutation) Geburtstag() (r time.Time, exists bool) {
	v := m._Geburtstag
	if v == nil {
		return
	}
	return *v, true
}

// OldGeburtstag returns the old "Geburtstag" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldGeburtstag(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeburtstag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeburtstag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeburtstag: %w", err)
	}
	return oldValue.Geburtstag, nil
}

// ClearGeburtstag clears the value of the "Geburtstag" field.
func (m *MitarbeiterMutation) ClearGeburtstag() {
	m._Geburtstag = nil
	m.clearedFields[mitarbeiter.FieldGeburtstag] = struct{}{}
}

// GeburtstagCleared returns if the "Geburtstag" field was cleared in this mutation.
func (m *MitarbeiterMutation) GeburtstagCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldGeburtstag]
	return ok
}

// ResetGeburtstag resets all changes to the "Geburtstag" field.
func (m *MitarbeiterMutation) ResetGeburtstag() {
	m._Geburtstag = nil
	delete(m.clearedFields, mitarbeiter.FieldGeburtstag)
}

// SetGruppenwahl sets the "Gruppenwahl" field.
func (m *MitarbeiterMutation) SetGruppenwahl(s string) {
	m._Gruppenwahl = &s
}

// Gruppenwahl returns the value of the "Gruppenwahl" field in the mutation.
func (m *MitarbeiterMutation) Gruppenwahl() (r string, exists bool) {
	v := m._Gruppenwahl
	if v == nil {
		return
	}
	return *v, true
}

// OldGruppenwahl returns the old "Gruppenwahl" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldGruppenwahl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGruppenwahl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGruppenwahl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGruppenwahl: %w", err)
	}
	return oldValue.Gruppenwahl, nil
}

// ClearGruppenwahl clears the value of the "Gruppenwahl" field.
func (m *MitarbeiterMutation) ClearGruppenwahl() {
	m._Gruppenwahl = nil
	m.clearedFields[mitarbeiter.FieldGruppenwahl] = struct{}{}
}

// GruppenwahlCleared returns if the "Gruppenwahl" field was cleared in this mutation.
func (m *MitarbeiterMutation) GruppenwahlCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldGruppenwahl]
	return ok
}

// ResetGruppenwahl resets all changes to the "Gruppenwahl" field.
func (m *MitarbeiterMutation) ResetGruppenwahl() {
	m._Gruppenwahl = nil
	delete(m.clearedFields, mitarbeiter.FieldGruppenwahl)
}

// SetHomeOffice sets the "HomeOffice" field.
func (m *MitarbeiterMutation) SetHomeOffice(s string) {
	m._HomeOffice = &s
}

// HomeOffice returns the value of the "HomeOffice" field in the mutation.
func (m *MitarbeiterMutation) HomeOffice() (r string, exists bool) {
	v := m._HomeOffice
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeOffice returns the old "HomeOffice" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldHomeOffice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeOffice: %w", err)
	}
	return oldValue.HomeOffice, nil
}

// ClearHomeOffice clears the value of the "HomeOffice" field.
func (m *MitarbeiterMutation) ClearHomeOffice() {
	m._HomeOffice = nil
	m.clearedFields[mitarbeiter.FieldHomeOffice] = struct{}{}
}

// HomeOfficeCleared returns if the "HomeOffice" field was cleared in this mutation.
func (m *MitarbeiterMutation) HomeOfficeCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldHomeOffice]
	return ok
}

// ResetHomeOffice resets all changes to the "HomeOffice" field.
func (m *MitarbeiterMutation) ResetHomeOffice() {
	m._HomeOffice = nil
	delete(m.clearedFields, mitarbeiter.FieldHomeOffice)
}

// SetMobilBusiness sets the "Mobil_Business" field.
func (m *MitarbeiterMutation) SetMobilBusiness(s string) {
	m._Mobil_Business = &s
}

// MobilBusiness returns the value of the "Mobil_Business" field in the mutation.
func (m *MitarbeiterMutation) MobilBusiness() (r string, exists bool) {
	v := m._Mobil_Business
	if v == nil {
		return
	}
	return *v, true
}

// OldMobilBusiness returns the old "Mobil_Business" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldMobilBusiness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobilBusiness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobilBusiness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobilBusiness: %w", err)
	}
	return oldValue.MobilBusiness, nil
}

// ClearMobilBusiness clears the value of the "Mobil_Business" field.
func (m *MitarbeiterMutation) ClearMobilBusiness() {
	m._Mobil_Business = nil
	m.clearedFields[mitarbeiter.FieldMobilBusiness] = struct{}{}
}

// MobilBusinessCleared returns if the "Mobil_Business" field was cleared in this mutation.
func (m *MitarbeiterMutation) MobilBusinessCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldMobilBusiness]
	return ok
}

// ResetMobilBusiness resets all changes to the "Mobil_Business" field.
func (m *MitarbeiterMutation) ResetMobilBusiness() {
	m._Mobil_Business = nil
	delete(m.clearedFields, mitarbeiter.FieldMobilBusiness)
}

// SetMobilPrivat sets the "Mobil_Privat" field.
func (m *MitarbeiterMutation) SetMobilPrivat(s string) {
	m._Mobil_Privat = &s
}

// MobilPrivat returns the value of the "Mobil_Privat" field in the mutation.
func (m *MitarbeiterMutation) MobilPrivat() (r string, exists bool) {
	v := m._Mobil_Privat
	if v == nil {
		return
	}
	return *v, true
}

// OldMobilPrivat returns the old "Mobil_Privat" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldMobilPrivat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobilPrivat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobilPrivat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobilPrivat: %w", err)
	}
	return oldValue.MobilPrivat, nil
}

// ClearMobilPrivat clears the value of the "Mobil_Privat" field.
func (m *MitarbeiterMutation) ClearMobilPrivat() {
	m._Mobil_Privat = nil
	m.clearedFields[mitarbeiter.FieldMobilPrivat] = struct{}{}
}

// MobilPrivatCleared returns if the "Mobil_Privat" field was cleared in this mutation.
func (m *MitarbeiterMutation) MobilPrivatCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldMobilPrivat]
	return ok
}

// ResetMobilPrivat resets all changes to the "Mobil_Privat" field.
func (m *MitarbeiterMutation) ResetMobilPrivat() {
	m._Mobil_Privat = nil
	delete(m.clearedFields, mitarbeiter.FieldMobilPrivat)
}

// SetTelefonBusiness sets the "Telefon_Business" field.
func (m *MitarbeiterMutation) SetTelefonBusiness(s string) {
	m._Telefon_Business = &s
}

// TelefonBusiness returns the value of the "Telefon_Business" field in the mutation.
func (m *MitarbeiterMutation) TelefonBusiness() (r string, exists bool) {
	v := m._Telefon_Business
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefonBusiness returns the old "Telefon_Business" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldTelefonBusiness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefonBusiness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefonBusiness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefonBusiness: %w", err)
	}
	return oldValue.TelefonBusiness, nil
}

// ClearTelefonBusiness clears the value of the "Telefon_Business" field.
func (m *MitarbeiterMutation) ClearTelefonBusiness() {
	m._Telefon_Business = nil
	m.clearedFields[mitarbeiter.FieldTelefonBusiness] = struct{}{}
}

// TelefonBusinessCleared returns if the "Telefon_Business" field was cleared in this mutation.
func (m *MitarbeiterMutation) TelefonBusinessCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldTelefonBusiness]
	return ok
}

// ResetTelefonBusiness resets all changes to the "Telefon_Business" field.
func (m *MitarbeiterMutation) ResetTelefonBusiness() {
	m._Telefon_Business = nil
	delete(m.clearedFields, mitarbeiter.FieldTelefonBusiness)
}

// SetTelefonIntern1 sets the "Telefon_Intern_1" field.
func (m *MitarbeiterMutation) SetTelefonIntern1(s string) {
	m._Telefon_Intern_1 = &s
}

// TelefonIntern1 returns the value of the "Telefon_Intern_1" field in the mutation.
func (m *MitarbeiterMutation) TelefonIntern1() (r string, exists bool) {
	v := m._Telefon_Intern_1
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefonIntern1 returns the old "Telefon_Intern_1" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldTelefonIntern1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefonIntern1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefonIntern1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefonIntern1: %w", err)
	}
	return oldValue.TelefonIntern1, nil
}

// ClearTelefonIntern1 clears the value of the "Telefon_Intern_1" field.
func (m *MitarbeiterMutation) ClearTelefonIntern1() {
	m._Telefon_Intern_1 = nil
	m.clearedFields[mitarbeiter.FieldTelefonIntern1] = struct{}{}
}

// TelefonIntern1Cleared returns if the "Telefon_Intern_1" field was cleared in this mutation.
func (m *MitarbeiterMutation) TelefonIntern1Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldTelefonIntern1]
	return ok
}

// ResetTelefonIntern1 resets all changes to the "Telefon_Intern_1" field.
func (m *MitarbeiterMutation) ResetTelefonIntern1() {
	m._Telefon_Intern_1 = nil
	delete(m.clearedFields, mitarbeiter.FieldTelefonIntern1)
}

// SetTelefonIntern2 sets the "Telefon_Intern_2" field.
func (m *MitarbeiterMutation) SetTelefonIntern2(s string) {
	m._Telefon_Intern_2 = &s
}

// TelefonIntern2 returns the value of the "Telefon_Intern_2" field in the mutation.
func (m *MitarbeiterMutation) TelefonIntern2() (r string, exists bool) {
	v := m._Telefon_Intern_2
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefonIntern2 returns the old "Telefon_Intern_2" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldTelefonIntern2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefonIntern2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefonIntern2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefonIntern2: %w", err)
	}
	return oldValue.TelefonIntern2, nil
}

// ClearTelefonIntern2 clears the value of the "Telefon_Intern_2" field.
func (m *MitarbeiterMutation) ClearTelefonIntern2() {
	m._Telefon_Intern_2 = nil
	m.clearedFields[mitarbeiter.FieldTelefonIntern2] = struct{}{}
}

// TelefonIntern2Cleared returns if the "Telefon_Intern_2" field was cleared in this mutation.
func (m *MitarbeiterMutation) TelefonIntern2Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldTelefonIntern2]
	return ok
}

// ResetTelefonIntern2 resets all changes to the "Telefon_Intern_2" field.
func (m *MitarbeiterMutation) ResetTelefonIntern2() {
	m._Telefon_Intern_2 = nil
	delete(m.clearedFields, mitarbeiter.FieldTelefonIntern2)
}

// SetTelefonPrivat sets the "Telefon_Privat" field.
func (m *MitarbeiterMutation) SetTelefonPrivat(s string) {
	m._Telefon_Privat = &s
}

// TelefonPrivat returns the value of the "Telefon_Privat" field in the mutation.
func (m *MitarbeiterMutation) TelefonPrivat() (r string, exists bool) {
	v := m._Telefon_Privat
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefonPrivat returns the old "Telefon_Privat" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldTelefonPrivat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefonPrivat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefonPrivat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefonPrivat: %w", err)
	}
	return oldValue.TelefonPrivat, nil
}

// ClearTelefonPrivat clears the value of the "Telefon_Privat" field.
func (m *MitarbeiterMutation) ClearTelefonPrivat() {
	m._Telefon_Privat = nil
	m.clearedFields[mitarbeiter.FieldTelefonPrivat] = struct{}{}
}

// TelefonPrivatCleared returns if the "Telefon_Privat" field was cleared in this mutation.
func (m *MitarbeiterMutation) TelefonPrivatCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldTelefonPrivat]
	return ok
}

// ResetTelefonPrivat resets all changes to the "Telefon_Privat" field.
func (m *MitarbeiterMutation) ResetTelefonPrivat() {
	m._Telefon_Privat = nil
	delete(m.clearedFields, mitarbeiter.FieldTelefonPrivat)
}

// SetAbteilungID sets the "abteilung" edge to the Abteilung entity by id.
func (m *MitarbeiterMutation) SetAbteilungID(id string) {
	m.abteilung = &id
}

// ClearAbteilung clears the "abteilung" edge to the Abteilung entity.
func (m *MitarbeiterMutation) ClearAbteilung() {
	m.clearedabteilung = true
	m.clearedFields[mitarbeiter.FieldAbteilungId] = struct{}{}
}

// AbteilungCleared reports if the "abteilung" edge to the Abteilung entity was cleared.
func (m *MitarbeiterMutation) AbteilungCleared() bool {
	return m.AbteilungIdCleared() || m.clearedabteilung
}

// AbteilungID returns the "abteilung" edge ID in the mutation.
func (m *MitarbeiterMutation) AbteilungID() (id string, exists bool) {
	if m.abteilung != nil {
		return *m.abteilung, true
	}
	return
}

// AbteilungIDs returns the "abteilung" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbteilungID instead. It exists only for internal usage by the builders.
func (m *MitarbeiterMutation) AbteilungIDs() (ids []string) {
	if id := m.abteilung; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbteilung resets all changes to the "abteilung" edge.
func (m *MitarbeiterMutation) ResetAbteilung() {
	m.abteilung = nil
	m.clearedabteilung = false
}

// SetEinkaufID sets the "einkauf" edge to the Einkauf entity by id.
func (m *MitarbeiterMutation) SetEinkaufID(id string) {
	m.einkauf = &id
}

// ClearEinkauf clears the "einkauf" edge to the Einkauf entity.
func (m *MitarbeiterMutation) ClearEinkauf() {
	m.clearedeinkauf = true
	m.clearedFields[mitarbeiter.FieldEinkaufId] = struct{}{}
}

// EinkaufCleared reports if the "einkauf" edge to the Einkauf entity was cleared.
func (m *MitarbeiterMutation) EinkaufCleared() bool {
	return m.EinkaufIdCleared() || m.clearedeinkauf
}

// EinkaufID returns the "einkauf" edge ID in the mutation.
func (m *MitarbeiterMutation) EinkaufID() (id string, exists bool) {
	if m.einkauf != nil {
		return *m.einkauf, true
	}
	return
}

// EinkaufIDs returns the "einkauf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EinkaufID instead. It exists only for internal usage by the builders.
func (m *MitarbeiterMutation) EinkaufIDs() (ids []string) {
	if id := m.einkauf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEinkauf resets all changes to the "einkauf" edge.
func (m *MitarbeiterMutation) ResetEinkauf() {
	m.einkauf = nil
	m.clearedeinkauf = false
}

// Where appends a list predicates to the MitarbeiterMutation builder.
func (m *MitarbeiterMutation) Where(ps ...predicate.Mitarbeiter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MitarbeiterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MitarbeiterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mitarbeiter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MitarbeiterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MitarbeiterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mitarbeiter).
func (m *MitarbeiterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MitarbeiterMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, mitarbeiter.FieldName)
	}
	if m.short != nil {
		fields = append(fields, mitarbeiter.FieldShort)
	}
	if m.image != nil {
		fields = append(fields, mitarbeiter.FieldImage)
	}
	if m.sex != nil {
		fields = append(fields, mitarbeiter.FieldSex)
	}
	if m.focus != nil {
		fields = append(fields, mitarbeiter.FieldFocus)
	}
	if m.mail != nil {
		fields = append(fields, mitarbeiter.FieldMail)
	}
	if m.abteilung != nil {
		fields = append(fields, mitarbeiter.FieldAbteilungId)
	}
	if m.einkauf != nil {
		fields = append(fields, mitarbeiter.FieldEinkaufId)
	}
	if m._Azubi != nil {
		fields = append(fields, mitarbeiter.FieldAzubi)
	}
	if m._Geburtstag != nil {
		fields = append(fields, mitarbeiter.FieldGeburtstag)
	}
	if m._Gruppenwahl != nil {
		fields = append(fields, mitarbeiter.FieldGruppenwahl)
	}
	if m._HomeOffice != nil {
		fields = append(fields, mitarbeiter.FieldHomeOffice)
	}
	if m._Mobil_Business != nil {
		fields = append(fields, mitarbeiter.FieldMobilBusiness)
	}
	if m._Mobil_Privat != nil {
		fields = append(fields, mitarbeiter.FieldMobilPrivat)
	}
	if m._Telefon_Business != nil {
		fields = append(fields, mitarbeiter.FieldTelefonBusiness)
	}
	if m._Telefon_Intern_1 != nil {
		fields = append(fields, mitarbeiter.FieldTelefonIntern1)
	}
	if m._Telefon_Intern_2 != nil {
		fields = append(fields, mitarbeiter.FieldTelefonIntern2)
	}
	if m._Telefon_Privat != nil {
		fields = append(fields, mitarbeiter.FieldTelefonPrivat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MitarbeiterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mitarbeiter.FieldName:
		return m.Name()
	case mitarbeiter.FieldShort:
		return m.Short()
	case mitarbeiter.FieldImage:
		return m.Image()
	case mitarbeiter.FieldSex:
		return m.Sex()
	case mitarbeiter.FieldFocus:
		return m.Focus()
	case mitarbeiter.FieldMail:
		return m.Mail()
	case mitarbeiter.FieldAbteilungId:
		return m.AbteilungId()
	case mitarbeiter.FieldEinkaufId:
		return m.EinkaufId()
	case mitarbeiter.FieldAzubi:
		return m.Azubi()
	case mitarbeiter.FieldGeburtstag:
		return m.Geburtstag()
	case mitarbeiter.FieldGruppenwahl:
		return m.Gruppenwahl()
	case mitarbeiter.FieldHomeOffice:
		return m.HomeOffice()
	case mitarbeiter.FieldMobilBusiness:
		return m.MobilBusiness()
	case mitarbeiter.FieldMobilPrivat:
		return m.MobilPrivat()
	case mitarbeiter.FieldTelefonBusiness:
		return m.TelefonBusiness()
	case mitarbeiter.FieldTelefonIntern1:
		return m.TelefonIntern1()
	case mitarbeiter.FieldTelefonIntern2:
		return m.TelefonIntern2()
	case mitarbeiter.FieldTelefonPrivat:
		return m.TelefonPrivat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MitarbeiterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mitarbeiter.FieldName:
		return m.OldName(ctx)
	case mitarbeiter.FieldShort:
		return m.OldShort(ctx)
	case mitarbeiter.FieldImage:
		return m.OldImage(ctx)
	case mitarbeiter.FieldSex:
		return m.OldSex(ctx)
	case mitarbeiter.FieldFocus:
		return m.OldFocus(ctx)
	case mitarbeiter.FieldMail:
		return m.OldMail(ctx)
	case mitarbeiter.FieldAbteilungId:
		return m.OldAbteilungId(ctx)
	case mitarbeiter.FieldEinkaufId:
		return m.OldEinkaufId(ctx)
	case mitarbeiter.FieldAzubi:
		return m.OldAzubi(ctx)
	case mitarbeiter.FieldGeburtstag:
		return m.OldGeburtstag(ctx)
	case mitarbeiter.FieldGruppenwahl:
		return m.OldGruppenwahl(ctx)
	case mitarbeiter.FieldHomeOffice:
		return m.OldHomeOffice(ctx)
	case mitarbeiter.FieldMobilBusiness:
		return m.OldMobilBusiness(ctx)
	case mitarbeiter.FieldMobilPrivat:
		return m.OldMobilPrivat(ctx)
	case mitarbeiter.FieldTelefonBusiness:
		return m.OldTelefonBusiness(ctx)
	case mitarbeiter.FieldTelefonIntern1:
		return m.OldTelefonIntern1(ctx)
	case mitarbeiter.FieldTelefonIntern2:
		return m.OldTelefonIntern2(ctx)
	case mitarbeiter.FieldTelefonPrivat:
		return m.OldTelefonPrivat(ctx)
	}
	return nil, fmt.Errorf("unknown Mitarbeiter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MitarbeiterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mitarbeiter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mitarbeiter.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case mitarbeiter.FieldImage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case mitarbeiter.FieldSex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case mitarbeiter.FieldFocus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFocus(v)
		return nil
	case mitarbeiter.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case mitarbeiter.FieldAbteilungId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbteilungId(v)
		return nil
	case mitarbeiter.FieldEinkaufId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEinkaufId(v)
		return nil
	case mitarbeiter.FieldAzubi:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAzubi(v)
		return nil
	case mitarbeiter.FieldGeburtstag:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeburtstag(v)
		return nil
	case mitarbeiter.FieldGruppenwahl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGruppenwahl(v)
		return nil
	case mitarbeiter.FieldHomeOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeOffice(v)
		return nil
	case mitarbeiter.FieldMobilBusiness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobilBusiness(v)
		return nil
	case mitarbeiter.FieldMobilPrivat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobilPrivat(v)
		return nil
	case mitarbeiter.FieldTelefonBusiness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefonBusiness(v)
		return nil
	case mitarbeiter.FieldTelefonIntern1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefonIntern1(v)
		return nil
	case mitarbeiter.FieldTelefonIntern2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefonIntern2(v)
		return nil
	case mitarbeiter.FieldTelefonPrivat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefonPrivat(v)
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MitarbeiterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MitarbeiterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MitarbeiterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mitarbeiter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MitarbeiterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mitarbeiter.FieldShort) {
		fields = append(fields, mitarbeiter.FieldShort)
	}
	if m.FieldCleared(mitarbeiter.FieldSex) {
		fields = append(fields, mitarbeiter.FieldSex)
	}
	if m.FieldCleared(mitarbeiter.FieldFocus) {
		fields = append(fields, mitarbeiter.FieldFocus)
	}
	if m.FieldCleared(mitarbeiter.FieldMail) {
		fields = append(fields, mitarbeiter.FieldMail)
	}
	if m.FieldCleared(mitarbeiter.FieldAbteilungId) {
		fields = append(fields, mitarbeiter.FieldAbteilungId)
	}
	if m.FieldCleared(mitarbeiter.FieldEinkaufId) {
		fields = append(fields, mitarbeiter.FieldEinkaufId)
	}
	if m.FieldCleared(mitarbeiter.FieldGeburtstag) {
		fields = append(fields, mitarbeiter.FieldGeburtstag)
	}
	if m.FieldCleared(mitarbeiter.FieldGruppenwahl) {
		fields = append(fields, mitarbeiter.FieldGruppenwahl)
	}
	if m.FieldCleared(mitarbeiter.FieldHomeOffice) {
		fields = append(fields, mitarbeiter.FieldHomeOffice)
	}
	if m.FieldCleared(mitarbeiter.FieldMobilBusiness) {
		fields = append(fields, mitarbeiter.FieldMobilBusiness)
	}
	if m.FieldCleared(mitarbeiter.FieldMobilPrivat) {
		fields = append(fields, mitarbeiter.FieldMobilPrivat)
	}
	if m.FieldCleared(mitarbeiter.FieldTelefonBusiness) {
		fields = append(fields, mitarbeiter.FieldTelefonBusiness)
	}
	if m.FieldCleared(mitarbeiter.FieldTelefonIntern1) {
		fields = append(fields, mitarbeiter.FieldTelefonIntern1)
	}
	if m.FieldCleared(mitarbeiter.FieldTelefonIntern2) {
		fields = append(fields, mitarbeiter.FieldTelefonIntern2)
	}
	if m.FieldCleared(mitarbeiter.FieldTelefonPrivat) {
		fields = append(fields, mitarbeiter.FieldTelefonPrivat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MitarbeiterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MitarbeiterMutation) ClearField(name string) error {
	switch name {
	case mitarbeiter.FieldShort:
		m.ClearShort()
		return nil
	case mitarbeiter.FieldSex:
		m.ClearSex()
		return nil
	case mitarbeiter.FieldFocus:
		m.ClearFocus()
		return nil
	case mitarbeiter.FieldMail:
		m.ClearMail()
		return nil
	case mitarbeiter.FieldAbteilungId:
		m.ClearAbteilungId()
		return nil
	case mitarbeiter.FieldEinkaufId:
		m.ClearEinkaufId()
		return nil
	case mitarbeiter.FieldGeburtstag:
		m.ClearGeburtstag()
		return nil
	case mitarbeiter.FieldGruppenwahl:
		m.ClearGruppenwahl()
		return nil
	case mitarbeiter.FieldHomeOffice:
		m.ClearHomeOffice()
		return nil
	case mitarbeiter.FieldMobilBusiness:
		m.ClearMobilBusiness()
		return nil
	case mitarbeiter.FieldMobilPrivat:
		m.ClearMobilPrivat()
		return nil
	case mitarbeiter.FieldTelefonBusiness:
		m.ClearTelefonBusiness()
		return nil
	case mitarbeiter.FieldTelefonIntern1:
		m.ClearTelefonIntern1()
		return nil
	case mitarbeiter.FieldTelefonIntern2:
		m.ClearTelefonIntern2()
		return nil
	case mitarbeiter.FieldTelefonPrivat:
		m.ClearTelefonPrivat()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MitarbeiterMutation) ResetField(name string) error {
	switch name {
	case mitarbeiter.FieldName:
		m.ResetName()
		return nil
	case mitarbeiter.FieldShort:
		m.ResetShort()
		return nil
	case mitarbeiter.FieldImage:
		m.ResetImage()
		return nil
	case mitarbeiter.FieldSex:
		m.ResetSex()
		return nil
	case mitarbeiter.FieldFocus:
		m.ResetFocus()
		return nil
	case mitarbeiter.FieldMail:
		m.ResetMail()
		return nil
	case mitarbeiter.FieldAbteilungId:
		m.ResetAbteilungId()
		return nil
	case mitarbeiter.FieldEinkaufId:
		m.ResetEinkaufId()
		return nil
	case mitarbeiter.FieldAzubi:
		m.ResetAzubi()
		return nil
	case mitarbeiter.FieldGeburtstag:
		m.ResetGeburtstag()
		return nil
	case mitarbeiter.FieldGruppenwahl:
		m.ResetGruppenwahl()
		return nil
	case mitarbeiter.FieldHomeOffice:
		m.ResetHomeOffice()
		return nil
	case mitarbeiter.FieldMobilBusiness:
		m.ResetMobilBusiness()
		return nil
	case mitarbeiter.FieldMobilPrivat:
		m.ResetMobilPrivat()
		return nil
	case mitarbeiter.FieldTelefonBusiness:
		m.ResetTelefonBusiness()
		return nil
	case mitarbeiter.FieldTelefonIntern1:
		m.ResetTelefonIntern1()
		return nil
	case mitarbeiter.FieldTelefonIntern2:
		m.ResetTelefonIntern2()
		return nil
	case mitarbeiter.FieldTelefonPrivat:
		m.ResetTelefonPrivat()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MitarbeiterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.abteilung != nil {
		edges = append(edges, mitarbeiter.EdgeAbteilung)
	}
	if m.einkauf != nil {
		edges = append(edges, mitarbeiter.EdgeEinkauf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MitarbeiterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mitarbeiter.EdgeAbteilung:
		if id := m.abteilung; id != nil {
			return []ent.Value{*id}
		}
	case mitarbeiter.EdgeEinkauf:
		if id := m.einkauf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MitarbeiterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MitarbeiterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MitarbeiterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedabteilung {
		edges = append(edges, mitarbeiter.EdgeAbteilung)
	}
	if m.clearedeinkauf {
		edges = append(edges, mitarbeiter.EdgeEinkauf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MitarbeiterMutation) EdgeCleared(name string) bool {
	switch name {
	case mitarbeiter.EdgeAbteilung:
		return m.clearedabteilung
	case mitarbeiter.EdgeEinkauf:
		return m.clearedeinkauf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MitarbeiterMutation) ClearEdge(name string) error {
	switch name {
	case mitarbeiter.EdgeAbteilung:
		m.ClearAbteilung()
		return nil
	case mitarbeiter.EdgeEinkauf:
		m.ClearEinkauf()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MitarbeiterMutation) ResetEdge(name string) error {
	switch name {
	case mitarbeiter.EdgeAbteilung:
		m.ResetAbteilung()
		return nil
	case mitarbeiter.EdgeEinkauf:
		m.ResetEinkauf()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter edge %s", name)
}

// PartnerMutation represents an operation that mutates the Partner nodes in the graph.
type PartnerMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	link          *string
	image         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Partner, error)
	predicates    []predicate.Partner
}

var _ ent.Mutation = (*PartnerMutation)(nil)

// partnerOption allows management of the mutation configuration using functional options.
type partnerOption func(*PartnerMutation)

// newPartnerMutation creates new mutation for the Partner entity.
func newPartnerMutation(c config, op Op, opts ...partnerOption) *PartnerMutation {
	m := &PartnerMutation{
		config:        c,
		op:            op,
		typ:           TypePartner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerID sets the ID field of the mutation.
func withPartnerID(id string) partnerOption {
	return func(m *PartnerMutation) {
		var (
			err   error
			once  sync.Once
			value *Partner
		)
		m.oldValue = func(ctx context.Context) (*Partner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Partner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartner sets the old Partner of the mutation.
func withPartner(node *Partner) partnerOption {
	return func(m *PartnerMutation) {
		m.oldValue = func(context.Context) (*Partner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Partner entities.
func (m *PartnerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Partner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PartnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PartnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PartnerMutation) ResetName() {
	m.name = nil
}

// SetLink sets the "link" field.
func (m *PartnerMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *PartnerMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *PartnerMutation) ResetLink() {
	m.link = nil
}

// SetImage sets the "image" field.
func (m *PartnerMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *PartnerMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *PartnerMutation) ResetImage() {
	m.image = nil
}

// Where appends a list predicates to the PartnerMutation builder.
func (m *PartnerMutation) Where(ps ...predicate.Partner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Partner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Partner).
func (m *PartnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, partner.FieldName)
	}
	if m.link != nil {
		fields = append(fields, partner.FieldLink)
	}
	if m.image != nil {
		fields = append(fields, partner.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partner.FieldName:
		return m.Name()
	case partner.FieldLink:
		return m.Link()
	case partner.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partner.FieldName:
		return m.OldName(ctx)
	case partner.FieldLink:
		return m.OldLink(ctx)
	case partner.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Partner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case partner.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case partner.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Partner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Partner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Partner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerMutation) ResetField(name string) error {
	switch name {
	case partner.FieldName:
		m.ResetName()
		return nil
	case partner.FieldLink:
		m.ResetLink()
		return nil
	case partner.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Partner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Partner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Partner edge %s", name)
}

// PdfMutation represents an operation that mutates the Pdf nodes in the graph.
type PdfMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	title         *string
	body          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Pdf, error)
	predicates    []predicate.Pdf
}

var _ ent.Mutation = (*PdfMutation)(nil)

// pdfOption allows management of the mutation configuration using functional options.
type pdfOption func(*PdfMutation)

// newPdfMutation creates new mutation for the Pdf entity.
func newPdfMutation(c config, op Op, opts ...pdfOption) *PdfMutation {
	m := &PdfMutation{
		config:        c,
		op:            op,
		typ:           TypePdf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPdfID sets the ID field of the mutation.
func withPdfID(id int32) pdfOption {
	return func(m *PdfMutation) {
		var (
			err   error
			once  sync.Once
			value *Pdf
		)
		m.oldValue = func(ctx context.Context) (*Pdf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pdf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPdf sets the old Pdf of the mutation.
func withPdf(node *Pdf) pdfOption {
	return func(m *PdfMutation) {
		m.oldValue = func(context.Context) (*Pdf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PdfMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PdfMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pdf entities.
func (m *PdfMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PdfMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PdfMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pdf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PdfMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PdfMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Pdf entity.
// If the Pdf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PdfMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PdfMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *PdfMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PdfMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Pdf entity.
// If the Pdf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PdfMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *PdfMutation) ResetBody() {
	m.body = nil
}

// Where appends a list predicates to the PdfMutation builder.
func (m *PdfMutation) Where(ps ...predicate.Pdf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PdfMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PdfMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pdf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PdfMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PdfMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pdf).
func (m *PdfMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PdfMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.title != nil {
		fields = append(fields, pdf.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, pdf.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PdfMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pdf.FieldTitle:
		return m.Title()
	case pdf.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PdfMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pdf.FieldTitle:
		return m.OldTitle(ctx)
	case pdf.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown Pdf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PdfMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pdf.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case pdf.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown Pdf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PdfMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PdfMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PdfMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pdf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PdfMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PdfMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PdfMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pdf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PdfMutation) ResetField(name string) error {
	switch name {
	case pdf.FieldTitle:
		m.ResetTitle()
		return nil
	case pdf.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown Pdf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PdfMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PdfMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PdfMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PdfMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PdfMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PdfMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PdfMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pdf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PdfMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pdf edge %s", name)
}

// StatuMutation represents an operation that mutates the Statu nodes in the graph.
type StatuMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	status        *string
	since         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Statu, error)
	predicates    []predicate.Statu
}

var _ ent.Mutation = (*StatuMutation)(nil)

// statuOption allows management of the mutation configuration using functional options.
type statuOption func(*StatuMutation)

// newStatuMutation creates new mutation for the Statu entity.
func newStatuMutation(c config, op Op, opts ...statuOption) *StatuMutation {
	m := &StatuMutation{
		config:        c,
		op:            op,
		typ:           TypeStatu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatuID sets the ID field of the mutation.
func withStatuID(id int32) statuOption {
	return func(m *StatuMutation) {
		var (
			err   error
			once  sync.Once
			value *Statu
		)
		m.oldValue = func(ctx context.Context) (*Statu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatu sets the old Statu of the mutation.
func withStatu(node *Statu) statuOption {
	return func(m *StatuMutation) {
		m.oldValue = func(context.Context) (*Statu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statu entities.
func (m *StatuMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatuMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatuMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Statu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *StatuMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StatuMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Statu entity.
// If the Statu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatuMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StatuMutation) ResetStatus() {
	m.status = nil
}

// SetSince sets the "since" field.
func (m *StatuMutation) SetSince(s string) {
	m.since = &s
}

// Since returns the value of the "since" field in the mutation.
func (m *StatuMutation) Since() (r string, exists bool) {
	v := m.since
	if v == nil {
		return
	}
	return *v, true
}

// OldSince returns the old "since" field's value of the Statu entity.
// If the Statu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatuMutation) OldSince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSince: %w", err)
	}
	return oldValue.Since, nil
}

// ResetSince resets all changes to the "since" field.
func (m *StatuMutation) ResetSince() {
	m.since = nil
}

// Where appends a list predicates to the StatuMutation builder.
func (m *StatuMutation) Where(ps ...predicate.Statu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Statu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Statu).
func (m *StatuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatuMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, statu.FieldStatus)
	}
	if m.since != nil {
		fields = append(fields, statu.FieldSince)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statu.FieldStatus:
		return m.Status()
	case statu.FieldSince:
		return m.Since()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statu.FieldStatus:
		return m.OldStatus(ctx)
	case statu.FieldSince:
		return m.OldSince(ctx)
	}
	return nil, fmt.Errorf("unknown Statu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statu.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case statu.FieldSince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSince(v)
		return nil
	}
	return fmt.Errorf("unknown Statu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatuMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatuMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatuMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatuMutation) ResetField(name string) error {
	switch name {
	case statu.FieldStatus:
		m.ResetStatus()
		return nil
	case statu.FieldSince:
		m.ResetSince()
		return nil
	}
	return fmt.Errorf("unknown Statu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Statu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Statu edge %s", name)
}

// WarenlieferungMutation represents an operation that mutates the Warenlieferung nodes in the graph.
type WarenlieferungMutation struct {
	config
	op             Op
	typ            string
	id             *int32
	_Name          *string
	angelegt       *time.Time
	geliefert      *time.Time
	_AlterPreis    *float32
	add_AlterPreis *float32
	_NeuerPreis    *float32
	add_NeuerPreis *float32
	_Preis         *time.Time
	_Artikelnummer *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Warenlieferung, error)
	predicates     []predicate.Warenlieferung
}

var _ ent.Mutation = (*WarenlieferungMutation)(nil)

// warenlieferungOption allows management of the mutation configuration using functional options.
type warenlieferungOption func(*WarenlieferungMutation)

// newWarenlieferungMutation creates new mutation for the Warenlieferung entity.
func newWarenlieferungMutation(c config, op Op, opts ...warenlieferungOption) *WarenlieferungMutation {
	m := &WarenlieferungMutation{
		config:        c,
		op:            op,
		typ:           TypeWarenlieferung,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarenlieferungID sets the ID field of the mutation.
func withWarenlieferungID(id int32) warenlieferungOption {
	return func(m *WarenlieferungMutation) {
		var (
			err   error
			once  sync.Once
			value *Warenlieferung
		)
		m.oldValue = func(ctx context.Context) (*Warenlieferung, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Warenlieferung.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarenlieferung sets the old Warenlieferung of the mutation.
func withWarenlieferung(node *Warenlieferung) warenlieferungOption {
	return func(m *WarenlieferungMutation) {
		m.oldValue = func(context.Context) (*Warenlieferung, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarenlieferungMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarenlieferungMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Warenlieferung entities.
func (m *WarenlieferungMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarenlieferungMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarenlieferungMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Warenlieferung.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *WarenlieferungMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *WarenlieferungMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *WarenlieferungMutation) ResetName() {
	m._Name = nil
}

// SetAngelegt sets the "angelegt" field.
func (m *WarenlieferungMutation) SetAngelegt(t time.Time) {
	m.angelegt = &t
}

// Angelegt returns the value of the "angelegt" field in the mutation.
func (m *WarenlieferungMutation) Angelegt() (r time.Time, exists bool) {
	v := m.angelegt
	if v == nil {
		return
	}
	return *v, true
}

// OldAngelegt returns the old "angelegt" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldAngelegt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAngelegt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAngelegt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAngelegt: %w", err)
	}
	return oldValue.Angelegt, nil
}

// ResetAngelegt resets all changes to the "angelegt" field.
func (m *WarenlieferungMutation) ResetAngelegt() {
	m.angelegt = nil
}

// SetGeliefert sets the "geliefert" field.
func (m *WarenlieferungMutation) SetGeliefert(t time.Time) {
	m.geliefert = &t
}

// Geliefert returns the value of the "geliefert" field in the mutation.
func (m *WarenlieferungMutation) Geliefert() (r time.Time, exists bool) {
	v := m.geliefert
	if v == nil {
		return
	}
	return *v, true
}

// OldGeliefert returns the old "geliefert" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldGeliefert(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeliefert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeliefert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeliefert: %w", err)
	}
	return oldValue.Geliefert, nil
}

// ClearGeliefert clears the value of the "geliefert" field.
func (m *WarenlieferungMutation) ClearGeliefert() {
	m.geliefert = nil
	m.clearedFields[warenlieferung.FieldGeliefert] = struct{}{}
}

// GeliefertCleared returns if the "geliefert" field was cleared in this mutation.
func (m *WarenlieferungMutation) GeliefertCleared() bool {
	_, ok := m.clearedFields[warenlieferung.FieldGeliefert]
	return ok
}

// ResetGeliefert resets all changes to the "geliefert" field.
func (m *WarenlieferungMutation) ResetGeliefert() {
	m.geliefert = nil
	delete(m.clearedFields, warenlieferung.FieldGeliefert)
}

// SetAlterPreis sets the "AlterPreis" field.
func (m *WarenlieferungMutation) SetAlterPreis(f float32) {
	m._AlterPreis = &f
	m.add_AlterPreis = nil
}

// AlterPreis returns the value of the "AlterPreis" field in the mutation.
func (m *WarenlieferungMutation) AlterPreis() (r float32, exists bool) {
	v := m._AlterPreis
	if v == nil {
		return
	}
	return *v, true
}

// OldAlterPreis returns the old "AlterPreis" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldAlterPreis(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlterPreis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlterPreis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlterPreis: %w", err)
	}
	return oldValue.AlterPreis, nil
}

// AddAlterPreis adds f to the "AlterPreis" field.
func (m *WarenlieferungMutation) AddAlterPreis(f float32) {
	if m.add_AlterPreis != nil {
		*m.add_AlterPreis += f
	} else {
		m.add_AlterPreis = &f
	}
}

// AddedAlterPreis returns the value that was added to the "AlterPreis" field in this mutation.
func (m *WarenlieferungMutation) AddedAlterPreis() (r float32, exists bool) {
	v := m.add_AlterPreis
	if v == nil {
		return
	}
	return *v, true
}

// ClearAlterPreis clears the value of the "AlterPreis" field.
func (m *WarenlieferungMutation) ClearAlterPreis() {
	m._AlterPreis = nil
	m.add_AlterPreis = nil
	m.clearedFields[warenlieferung.FieldAlterPreis] = struct{}{}
}

// AlterPreisCleared returns if the "AlterPreis" field was cleared in this mutation.
func (m *WarenlieferungMutation) AlterPreisCleared() bool {
	_, ok := m.clearedFields[warenlieferung.FieldAlterPreis]
	return ok
}

// ResetAlterPreis resets all changes to the "AlterPreis" field.
func (m *WarenlieferungMutation) ResetAlterPreis() {
	m._AlterPreis = nil
	m.add_AlterPreis = nil
	delete(m.clearedFields, warenlieferung.FieldAlterPreis)
}

// SetNeuerPreis sets the "NeuerPreis" field.
func (m *WarenlieferungMutation) SetNeuerPreis(f float32) {
	m._NeuerPreis = &f
	m.add_NeuerPreis = nil
}

// NeuerPreis returns the value of the "NeuerPreis" field in the mutation.
func (m *WarenlieferungMutation) NeuerPreis() (r float32, exists bool) {
	v := m._NeuerPreis
	if v == nil {
		return
	}
	return *v, true
}

// OldNeuerPreis returns the old "NeuerPreis" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldNeuerPreis(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeuerPreis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeuerPreis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeuerPreis: %w", err)
	}
	return oldValue.NeuerPreis, nil
}

// AddNeuerPreis adds f to the "NeuerPreis" field.
func (m *WarenlieferungMutation) AddNeuerPreis(f float32) {
	if m.add_NeuerPreis != nil {
		*m.add_NeuerPreis += f
	} else {
		m.add_NeuerPreis = &f
	}
}

// AddedNeuerPreis returns the value that was added to the "NeuerPreis" field in this mutation.
func (m *WarenlieferungMutation) AddedNeuerPreis() (r float32, exists bool) {
	v := m.add_NeuerPreis
	if v == nil {
		return
	}
	return *v, true
}

// ClearNeuerPreis clears the value of the "NeuerPreis" field.
func (m *WarenlieferungMutation) ClearNeuerPreis() {
	m._NeuerPreis = nil
	m.add_NeuerPreis = nil
	m.clearedFields[warenlieferung.FieldNeuerPreis] = struct{}{}
}

// NeuerPreisCleared returns if the "NeuerPreis" field was cleared in this mutation.
func (m *WarenlieferungMutation) NeuerPreisCleared() bool {
	_, ok := m.clearedFields[warenlieferung.FieldNeuerPreis]
	return ok
}

// ResetNeuerPreis resets all changes to the "NeuerPreis" field.
func (m *WarenlieferungMutation) ResetNeuerPreis() {
	m._NeuerPreis = nil
	m.add_NeuerPreis = nil
	delete(m.clearedFields, warenlieferung.FieldNeuerPreis)
}

// SetPreis sets the "Preis" field.
func (m *WarenlieferungMutation) SetPreis(t time.Time) {
	m._Preis = &t
}

// Preis returns the value of the "Preis" field in the mutation.
func (m *WarenlieferungMutation) Preis() (r time.Time, exists bool) {
	v := m._Preis
	if v == nil {
		return
	}
	return *v, true
}

// OldPreis returns the old "Preis" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldPreis(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreis: %w", err)
	}
	return oldValue.Preis, nil
}

// ClearPreis clears the value of the "Preis" field.
func (m *WarenlieferungMutation) ClearPreis() {
	m._Preis = nil
	m.clearedFields[warenlieferung.FieldPreis] = struct{}{}
}

// PreisCleared returns if the "Preis" field was cleared in this mutation.
func (m *WarenlieferungMutation) PreisCleared() bool {
	_, ok := m.clearedFields[warenlieferung.FieldPreis]
	return ok
}

// ResetPreis resets all changes to the "Preis" field.
func (m *WarenlieferungMutation) ResetPreis() {
	m._Preis = nil
	delete(m.clearedFields, warenlieferung.FieldPreis)
}

// SetArtikelnummer sets the "Artikelnummer" field.
func (m *WarenlieferungMutation) SetArtikelnummer(s string) {
	m._Artikelnummer = &s
}

// Artikelnummer returns the value of the "Artikelnummer" field in the mutation.
func (m *WarenlieferungMutation) Artikelnummer() (r string, exists bool) {
	v := m._Artikelnummer
	if v == nil {
		return
	}
	return *v, true
}

// OldArtikelnummer returns the old "Artikelnummer" field's value of the Warenlieferung entity.
// If the Warenlieferung object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarenlieferungMutation) OldArtikelnummer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtikelnummer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtikelnummer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtikelnummer: %w", err)
	}
	return oldValue.Artikelnummer, nil
}

// ResetArtikelnummer resets all changes to the "Artikelnummer" field.
func (m *WarenlieferungMutation) ResetArtikelnummer() {
	m._Artikelnummer = nil
}

// Where appends a list predicates to the WarenlieferungMutation builder.
func (m *WarenlieferungMutation) Where(ps ...predicate.Warenlieferung) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarenlieferungMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarenlieferungMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Warenlieferung, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarenlieferungMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarenlieferungMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Warenlieferung).
func (m *WarenlieferungMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarenlieferungMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Name != nil {
		fields = append(fields, warenlieferung.FieldName)
	}
	if m.angelegt != nil {
		fields = append(fields, warenlieferung.FieldAngelegt)
	}
	if m.geliefert != nil {
		fields = append(fields, warenlieferung.FieldGeliefert)
	}
	if m._AlterPreis != nil {
		fields = append(fields, warenlieferung.FieldAlterPreis)
	}
	if m._NeuerPreis != nil {
		fields = append(fields, warenlieferung.FieldNeuerPreis)
	}
	if m._Preis != nil {
		fields = append(fields, warenlieferung.FieldPreis)
	}
	if m._Artikelnummer != nil {
		fields = append(fields, warenlieferung.FieldArtikelnummer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarenlieferungMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warenlieferung.FieldName:
		return m.Name()
	case warenlieferung.FieldAngelegt:
		return m.Angelegt()
	case warenlieferung.FieldGeliefert:
		return m.Geliefert()
	case warenlieferung.FieldAlterPreis:
		return m.AlterPreis()
	case warenlieferung.FieldNeuerPreis:
		return m.NeuerPreis()
	case warenlieferung.FieldPreis:
		return m.Preis()
	case warenlieferung.FieldArtikelnummer:
		return m.Artikelnummer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarenlieferungMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warenlieferung.FieldName:
		return m.OldName(ctx)
	case warenlieferung.FieldAngelegt:
		return m.OldAngelegt(ctx)
	case warenlieferung.FieldGeliefert:
		return m.OldGeliefert(ctx)
	case warenlieferung.FieldAlterPreis:
		return m.OldAlterPreis(ctx)
	case warenlieferung.FieldNeuerPreis:
		return m.OldNeuerPreis(ctx)
	case warenlieferung.FieldPreis:
		return m.OldPreis(ctx)
	case warenlieferung.FieldArtikelnummer:
		return m.OldArtikelnummer(ctx)
	}
	return nil, fmt.Errorf("unknown Warenlieferung field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarenlieferungMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warenlieferung.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case warenlieferung.FieldAngelegt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAngelegt(v)
		return nil
	case warenlieferung.FieldGeliefert:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeliefert(v)
		return nil
	case warenlieferung.FieldAlterPreis:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlterPreis(v)
		return nil
	case warenlieferung.FieldNeuerPreis:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeuerPreis(v)
		return nil
	case warenlieferung.FieldPreis:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreis(v)
		return nil
	case warenlieferung.FieldArtikelnummer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtikelnummer(v)
		return nil
	}
	return fmt.Errorf("unknown Warenlieferung field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarenlieferungMutation) AddedFields() []string {
	var fields []string
	if m.add_AlterPreis != nil {
		fields = append(fields, warenlieferung.FieldAlterPreis)
	}
	if m.add_NeuerPreis != nil {
		fields = append(fields, warenlieferung.FieldNeuerPreis)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarenlieferungMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case warenlieferung.FieldAlterPreis:
		return m.AddedAlterPreis()
	case warenlieferung.FieldNeuerPreis:
		return m.AddedNeuerPreis()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarenlieferungMutation) AddField(name string, value ent.Value) error {
	switch name {
	case warenlieferung.FieldAlterPreis:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlterPreis(v)
		return nil
	case warenlieferung.FieldNeuerPreis:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNeuerPreis(v)
		return nil
	}
	return fmt.Errorf("unknown Warenlieferung numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarenlieferungMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warenlieferung.FieldGeliefert) {
		fields = append(fields, warenlieferung.FieldGeliefert)
	}
	if m.FieldCleared(warenlieferung.FieldAlterPreis) {
		fields = append(fields, warenlieferung.FieldAlterPreis)
	}
	if m.FieldCleared(warenlieferung.FieldNeuerPreis) {
		fields = append(fields, warenlieferung.FieldNeuerPreis)
	}
	if m.FieldCleared(warenlieferung.FieldPreis) {
		fields = append(fields, warenlieferung.FieldPreis)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarenlieferungMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarenlieferungMutation) ClearField(name string) error {
	switch name {
	case warenlieferung.FieldGeliefert:
		m.ClearGeliefert()
		return nil
	case warenlieferung.FieldAlterPreis:
		m.ClearAlterPreis()
		return nil
	case warenlieferung.FieldNeuerPreis:
		m.ClearNeuerPreis()
		return nil
	case warenlieferung.FieldPreis:
		m.ClearPreis()
		return nil
	}
	return fmt.Errorf("unknown Warenlieferung nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarenlieferungMutation) ResetField(name string) error {
	switch name {
	case warenlieferung.FieldName:
		m.ResetName()
		return nil
	case warenlieferung.FieldAngelegt:
		m.ResetAngelegt()
		return nil
	case warenlieferung.FieldGeliefert:
		m.ResetGeliefert()
		return nil
	case warenlieferung.FieldAlterPreis:
		m.ResetAlterPreis()
		return nil
	case warenlieferung.FieldNeuerPreis:
		m.ResetNeuerPreis()
		return nil
	case warenlieferung.FieldPreis:
		m.ResetPreis()
		return nil
	case warenlieferung.FieldArtikelnummer:
		m.ResetArtikelnummer()
		return nil
	}
	return fmt.Errorf("unknown Warenlieferung field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarenlieferungMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarenlieferungMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarenlieferungMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarenlieferungMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarenlieferungMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarenlieferungMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarenlieferungMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Warenlieferung unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarenlieferungMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Warenlieferung edge %s", name)
}
